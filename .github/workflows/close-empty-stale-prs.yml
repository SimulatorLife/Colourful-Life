name: PR Janitor – Close Empty Stale PRs

on:
  schedule:
    - cron: "*/30 */2 * * *" # runs every 2 hours
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: pr-janitor
  cancel-in-progress: false

jobs:
  close-empty-stale:
    runs-on: ubuntu-latest
    steps:
      - name: Find & close empty stale PRs
        uses: actions/github-script@v7
        with:
          # Uses the default GITHUB_TOKEN with the above permissions
          script: |
            const ONE_HOUR_MS = 1 * 60 * 60 * 1000;
            const now = Date.now();
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // Get all open PRs (paginated)
            const openPRs = await github.paginate(
              github.rest.pulls.list,
              { owner, repo, state: 'open', per_page: 100, sort: 'created', direction: 'asc' }
            );

            let closed = 0;
            let merged = 0;
            let branchesDeleted = 0;

            for (const pr of openPRs) {
              try {
                // Skip if created less than 1 hour ago
                const ageMs = now - new Date(pr.created_at).getTime();
                if (ageMs < ONE_HOUR_MS) continue;

                // Fetch details to get changed_files
                const { data: details } = await github.rest.pulls.get({
                  owner, repo, pull_number: pr.number
                });

                // changed_files is total diff file count between base & head
                if ((details.changed_files ?? 0) !== 0) continue;

                // Skip drafts
                if (details.draft) continue;

                let mergedThisPR = false;

                try {
                  const mergeResult = await github.rest.pulls.merge({
                    owner,
                    repo,
                    pull_number: pr.number,
                    merge_method: 'merge',
                    commit_title: `Auto-merge empty PR #${pr.number}`,
                    commit_message:
                      'Auto-merging empty PR detected by PR Janitor to keep the repository tidy.'
                  });

                  if (mergeResult?.data?.merged) {
                    mergedThisPR = true;
                    merged++;
                    core.info(`Merged PR #${pr.number} (${pr.title})`);

                    // Delete branch if it belongs to this repository and still exists
                    const headRepo = details.head?.repo?.full_name;
                    const headRef = details.head?.ref;
                    const baseRepoFullName = `${owner}/${repo}`;

                    const protectedBranches = new Set(['master', 'main', 'mainline']);

                    if (
                      headRepo === baseRepoFullName &&
                      headRef &&
                      headRef !== details.base?.ref &&
                      !protectedBranches.has(headRef)
                    ) {
                      try {
                        await github.rest.git.deleteRef({
                          owner,
                          repo,
                          ref: `heads/${headRef}`
                        });
                        branchesDeleted++;
                        core.info(`Deleted branch ${headRef} for PR #${pr.number}`);
                      } catch (deleteErr) {
                        core.warning(`Failed to delete branch ${headRef} for PR #${pr.number}: ${deleteErr.message}`);
                      }
                    } else if (protectedBranches.has(headRef)) {
                      core.info(`Skipping deletion of protected branch ${headRef} for PR #${pr.number}.`);
                    }

                    await github.rest.issues.createComment({
                      owner,
                      repo,
                      issue_number: pr.number,
                      body:
                        "Merged automatically: this PR had no file changes and was older than an hour. " +
                        "The source branch has been cleaned up where possible."
                    });

                    continue;
                  }
                } catch (mergeErr) {
                  core.info(`Unable to merge PR #${pr.number}: ${mergeErr.message}. Falling back to closing.`);
                }

                if (!mergedThisPR) {
                  // Post a brief explanation comment (optional but nice)
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: pr.number,
                    body:
                      "Closing automatically: this PR has been open for ≥1 hour and contains no file changes. " +
                      "If this was opened as a seed or placeholder, please push commits or open a new PR when ready."
                  });

                  // Close the PR
                  await github.rest.pulls.update({
                    owner,
                    repo,
                    pull_number: pr.number,
                    state: 'closed'
                  });

                  core.info(`Closed PR #${pr.number} (${pr.title})`);
                  closed++;
                }
              } catch (err) {
                core.warning(`Failed to process PR #${pr.number}: ${err.message}`);
              }
            }

            core.notice(`PR Janitor complete. Merged ${merged} PR(s), closed ${closed} PR(s), deleted ${branchesDeleted} branch(es).`);
