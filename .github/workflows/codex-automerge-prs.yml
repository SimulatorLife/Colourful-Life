name: Auto-merge Codex PRs

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
    branches: [master]
  push:
    branches:
      - codex/**

permissions:
  contents: write
  pull-requests: write

# Avoid overlapping runs per PR
concurrency:
  group: codex-automerge-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  merge-if-ready:
    if: ${{ startsWith(github.event_name, 'pull_request') || startsWith(github.ref, 'refs/heads/codex/') }}
    runs-on: ubuntu-latest

    steps:
      - name: Resolve PR number
        id: prnum
        uses: actions/github-script@v7
        with:
          script: |
            let number = null;
            if (context.eventName === 'pull_request') {
              number = context.payload.pull_request.number;
            } else {
              const branch = context.ref.replace('refs/heads/','');
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${branch}`
              });
              number = prs.length ? prs[0].number : null;
            }
            if (!number) { core.setOutput('skip','true'); return; }
            core.setOutput('skip','false');
            core.setOutput('number', String(number));

      - name: Read PR
        if: ${{ steps.prnum.outputs.skip != 'true' }}
        id: read
        uses: actions/github-script@v7
        with:
          script: |
            const n = Number('${{ steps.prnum.outputs.number }}');

            // Get fresh PR snapshot (mergeability can be null briefly)
            let pr;
            for (let i = 0; i < 10; i++) {
              const { data } = await github.rest.pulls.get({
                owner: context.repo.owner, repo: context.repo.repo, pull_number: n
              });
              pr = data;
              if (pr.mergeable !== null) break;
              await new Promise(r => setTimeout(r, 1000));
            }

            // Bail early if nothing to merge yet (seed PR)
            const hasRealChanges = (pr.commits || 0) > 1 && (pr.changed_files || 0) > 0;
            if (!hasRealChanges) {
              core.notice(`Bail: no real changes yet (commits=${pr.commits}, files=${pr.changed_files}).`);
              core.setOutput('bail','true');
              return;
            }

            const mergeable = !!pr.mergeable;
            const state = (pr.mergeable_state || 'unknown').toLowerCase(); // clean, unstable, dirty, blocked, behind, has_hooks
            const draft = !!pr.draft;

            core.setOutput('bail','false');
            core.setOutput('mergeable', mergeable ? 'true' : 'false');
            core.setOutput('state', state);
            core.setOutput('draft', draft ? 'true' : 'false');
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('number', String(n));

      - name: Merge
        if: ${{ steps.read.outputs.bail == 'false' && steps.read.outputs.mergeable == 'true' && steps.read.outputs.draft != 'true' && contains('clean,unstable,has_hooks', steps.read.outputs.state) }}
        uses: actions/github-script@v7
        id: merge
        with:
          script: |
            const n = Number('${{ steps.read.outputs.number }}');
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              pull_number: n,
              merge_method: 'squash'
            });
            core.setOutput('merged','true');

      - name: Delete branch
        if: ${{ steps.merge.outputs.merged == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const headRef = '${{ steps.read.outputs.head_ref }}';
            const protectedBranches = new Set(['master', 'main', 'mainline']);

            if (protectedBranches.has(headRef)) {
              core.info(`Skipping deletion of protected branch ${headRef}.`);
              return;
            }

            const ref = `heads/${headRef}`;

            try {
              await github.rest.git.deleteRef({ owner: context.repo.owner, repo: context.repo.repo, ref });
            } catch (e) {
              core.warning(`Branch deletion failed: ${e.message}`);
            }
