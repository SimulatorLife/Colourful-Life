name: Auto-merge Codex PRs

on:
  pull_request:
    types: [opened, reopened, synchronize, ready_for_review]
    branches: [master]
  push:
    branches:
      - codex/**
      - chore/auto-lint-format

permissions:
  contents: write
  pull-requests: write

# Avoid overlapping runs per PR
concurrency:
  group: codex-automerge-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: false

jobs:
  merge-if-ready:
    if: ${{ startsWith(github.event_name, 'pull_request') || startsWith(github.ref, 'refs/heads/codex/') || github.ref == 'refs/heads/chore/auto-lint-format' }}
    runs-on: ubuntu-latest

    steps:
      - name: Resolve PR number
        id: prnum
        uses: actions/github-script@v7
        with:
          script: |
            let number = null;
            if (context.eventName === 'pull_request') {
              number = context.payload.pull_request.number;
            } else {
              const branch = context.ref.replace('refs/heads/','');
              const { data: prs } = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${branch}`
              });
              number = prs.length ? prs[0].number : null;
            }
            if (!number) { core.setOutput('skip','true'); return; }
            core.setOutput('skip','false');
            core.setOutput('number', String(number));

      - name: Read PR
        if: ${{ steps.prnum.outputs.skip != 'true' }}
        id: read
        uses: actions/github-script@v7
        with:
          script: |
            const n = Number('${{ steps.prnum.outputs.number }}');
            const timeoutMs = 15 * 60 * 1000; // allow up to 15 minutes for checks to settle
            const pollDelayMs = 10000;
            const deadline = Date.now() + timeoutMs;

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));

            let pr;

            while (true) {
              const { data } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: n
              });
              pr = data;

              // GitHub may report mergeable=null until background mergeability checks finish.
              if (pr.mergeable === null) {
                if (Date.now() >= deadline) {
                  core.notice(`Bail: mergeability never resolved for PR #${n}.`);
                  core.setOutput('bail', 'true');
                  return;
                }
                await sleep(5000);
                continue;
              }

              const state = (pr.mergeable_state || 'unknown').toLowerCase();

              if (!pr.mergeable && state === 'blocked') {
                const sha = pr.head.sha;

                const combined = await github.rest.repos.getCombinedStatusForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha
                });

                const pendingStatuses = combined.statuses
                  .filter(status => status.state === 'pending')
                  .map(status => status.context);

                const failingStatuses = combined.statuses
                  .filter(status => status.state === 'failure' || status.state === 'error')
                  .map(status => status.context);

                const { data: checkRunsData } = await github.rest.checks.listForRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: sha,
                  per_page: 100
                });

                const pendingChecks = checkRunsData.check_runs
                  .filter(run => run.status !== 'completed')
                  .map(run => run.name);

                const failingChecks = checkRunsData.check_runs
                  .filter(run => run.status === 'completed' && ['failure', 'cancelled', 'timed_out', 'action_required', 'stale'].includes((run.conclusion || '').toLowerCase()))
                  .map(run => run.name);

                if (failingStatuses.length || failingChecks.length) {
                  core.notice(`Bail: failing checks detected (${[...failingStatuses, ...failingChecks].join(', ') || 'unknown'}).`);
                  core.setOutput('bail', 'true');
                  return;
                }

                if ((pendingStatuses.length || pendingChecks.length) && Date.now() < deadline) {
                  core.info(`Pending checks (${[...pendingStatuses, ...pendingChecks].join(', ')}) for PR #${n}; waiting to retry.`);
                  await sleep(pollDelayMs);
                  continue;
                }
              }

              break;
            }

            // Bail early if nothing to merge yet (seed PR)
            const hasRealChanges = (pr.changed_files || 0) > 0;
            if (!hasRealChanges) {
              core.notice(`Bail: no real changes yet (commits=${pr.commits}, files=${pr.changed_files}).`);
              core.setOutput('bail', 'true');
              return;
            }

            const mergeable = !!pr.mergeable;
            const state = (pr.mergeable_state || 'unknown').toLowerCase();
            const draft = !!pr.draft;

            core.setOutput('bail', 'false');
            core.setOutput('mergeable', mergeable ? 'true' : 'false');
            core.setOutput('state', state);
            core.setOutput('draft', draft ? 'true' : 'false');
            core.setOutput('head_ref', pr.head.ref);
            core.setOutput('number', String(n));

      - name: Merge
        if: ${{ steps.read.outputs.bail == 'false' && steps.read.outputs.mergeable == 'true' && steps.read.outputs.draft != 'true' && contains('clean,unstable,has_hooks', steps.read.outputs.state) }}
        uses: actions/github-script@v7
        id: merge
        with:
          script: |
            const n = Number('${{ steps.read.outputs.number }}');
            await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo:  context.repo.repo,
              pull_number: n,
              merge_method: 'squash'
            });
            core.setOutput('merged','true');

      - name: Delete branch
        if: ${{ steps.merge.outputs.merged == 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const headRef = '${{ steps.read.outputs.head_ref }}';
            const protectedBranches = new Set(['master', 'main', 'mainline']);

            if (protectedBranches.has(headRef)) {
              core.info(`Skipping deletion of protected branch ${headRef}.`);
              return;
            }

            const ref = `heads/${headRef}`;

            try {
              await github.rest.git.deleteRef({ owner: context.repo.owner, repo: context.repo.repo, ref });
            } catch (e) {
              core.warning(`Branch deletion failed: ${e.message}`);
            }
