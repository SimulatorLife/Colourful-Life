<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Simulation</title>
    <style>
      canvas {
        display: block;
        margin: 0 auto;
        background-color: #000;
      }
    </style>
  </head>
  <body>
    <canvas id="simulation" width="800" height="800"></canvas>
    <script>
      const canvas = document.getElementById('simulation');
      const ctx = canvas.getContext('2d');
      canvas.width = 800;
      canvas.height = 800;
      const cellSize = 10;
      const rows = canvas.height / cellSize;
      const cols = canvas.width / cellSize;
      const chanceToMutate = 0.1;
      const geneMutationRange = 0.2;
      const colors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
      const reservedColors = {
        flood: 'rgba(0, 0, 255, 0.3)',
        drought: 'rgba(139, 69, 19, 0.3)',
        heatwave: 'rgba(255, 0, 0, 0.3)',
        coldwave: 'rgba(255, 255, 255, 0.3)',
      };

      const grid = new Array(rows).fill(null).map(() => new Array(cols).fill(null));
      const organisms = [];
      let currentEvent = null;
      let eventCounter = 0;

      class Genes {
        constructor(
          colorIndex,
          sight,
          eventAwareness,
          curiosity,
          movementPattern,
          moveProbability,
          societyFormation,
          preferences
        ) {
          this.colorIndex = Math.round(colorIndex);
          this.color = colors[this.colorIndex];
          this.sight = sight;
          this.eventAwareness = eventAwareness;
          this.curiosity = curiosity;
          this.movementPattern = movementPattern;
          this.moveProbability = moveProbability;
          this.societyFormation = societyFormation;
          this.preferences = preferences;
        }
      }

      class Cell {
        constructor(row, col, genes) {
          this.row = row;
          this.col = col;
          this.genes = genes;
          this.color = genes.color;
          this.hunger = 0;
          this.currentSight = this.genes.sight;
          this.society = [];
        }

        move() {
          const newRow = this.row + Math.floor(Math.random() * 3) - 1;
          const newCol = this.col + Math.floor(Math.random() * 3) - 1;

          if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {
            if (!grid[newRow][newCol]) {
              grid[this.row][this.col] = null;
              grid[newRow][newCol] = this;

              this.row = newRow;
              this.col = newCol;
            }
          }
        }

        findTarget() {
          const dirRow = [-1, 0, 1];
          const dirCol = [-1, 0, 1];
          let targetRow, targetCol;

          for (const dr of dirRow) {
            for (const dc of dirCol) {
              const row = (this.row + dr + rows) % rows;
              const col = (this.col + dc + cols) % cols;
              const other = grid[row][col];

              if (other && other !== this && other.genes.colorIndex === this.genes.colorIndex) {
                targetRow = row;
                targetCol = col;
                break;
              }
            }
          }

          return { targetRow, targetCol };
        }

        static inheritGenes(parentA, parentB) {
          const preferences = parentA.genes.preferences.map((pref, index) => {
            return (
              (pref + parentB.genes.preferences[index]) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2)
            );
          });

          const newGenes = new Genes(
            (parentA.genes.colorIndex + parentB.genes.colorIndex) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2),
            (parentA.genes.sight + parentB.genes.sight) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2),
            (parentA.genes.eventAwareness + parentB.genes.eventAwareness) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2),
            (parentA.genes.curiosity + parentB.genes.curiosity) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2),
            (parentA.genes.movementPattern + parentB.genes.movementPattern) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2),
            (parentA.genes.moveProbability + parentB.genes.moveProbability) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2),
            (parentA.genes.societyFormation + parentB.genes.societyFormation) / 2 +
              (Math.random() * geneMutationRange - geneMutationRange / 2),
            preferences
          );
          return newGenes;
        }
      }

      // Event handling and reproduction
      function handleEvent() {
        if (currentEvent) {
          eventCounter--;
          if (eventCounter === 0) {
            currentEvent = null;
          }
        } else {
          if (Math.random() < 0.01) {
            const events = ['flood', 'drought', 'heatwave', 'coldwave'];
            currentEvent = events[Math.floor(Math.random() * events.length)];
            eventCounter = Math.floor(Math.random() * 50) + 50;
          }
        }
      }

      function reproduce() {
        const newOrganisms = [];

        for (const cell of organisms) {
          if (Math.random() < cell.genes.reproductionProbability) {
            const { targetRow, targetCol } = cell.findTarget();

            if (targetRow !== undefined && targetCol !== undefined) {
              const childGenes = mutate(cell.genes);
              const child = new Cell(targetRow, targetCol, childGenes);
              newOrganisms.push(child);
              grid[targetRow][targetCol] = child;
            }
          }
        }

        organisms.push(...newOrganisms);
      }

      // Simulation loop
      function simulationLoop() {
        handleEvent();

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        for (const cell of organisms) {
          if (Math.random() < cell.genes.moveProbability) {
            cell.move();
          }
        }

        reproduce();

        for (const cell of organisms) {
          ctx.fillStyle = cell.color;
          ctx.fillRect(cell.col * cellSize, cell.row * cellSize, cellSize, cellSize);
        }

        if (currentEvent) {
          ctx.fillStyle = reservedColors[currentEvent];
          ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        requestAnimationFrame(simulationLoop);
      }

      // Initialize organisms
      for (let i = 0; i < 100; i++) {
        const row = Math.floor(Math.random() * rows);
        const col = Math.floor(Math.random() * cols);

        if (!grid[row][col]) {
          const genes = new Genes(
            Math.floor(Math.random() * colors.length),
            Math.random(),
            Math.random(),
            Math.random(),
            Math.random(),
            Math.random(),
            Math.random(),
            [Math.random(), Math.random(), Math.random(), Math.random()]
          );

          const cell = new Cell(row, col, genes);
          grid[row][col] = cell;
          organisms.push(cell);
        }
      }

      simulationLoop();
    </script>
  </body>
</html>
