<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Evolution with Energy</title>
    <style>
        canvas {
            border: 1px solid #000;
        }
    </style>
</head>
<body>
<canvas id="world"></canvas>
<script>
const canvas = document.getElementById('world');
const ctx = canvas.getContext('2d');
canvas.width = 600;
canvas.height = 400;

const cellSize = 10;
const cols = Math.floor(canvas.width / cellSize);
const rows = Math.floor(canvas.height / cellSize);

// Grid storing organisms
const organisms = [];

// Secondary grid storing energy available on each tile
const maxTileEnergy = 5;
const regenRate = 0.05; // energy regenerated per tick per tile
const energyGrid = Array.from({ length: rows }, () => Array.from({ length: cols }, () => maxTileEnergy / 2));

class Cell {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.energy = 5;
    }

    move() {
        if (this.energy <= 0) return; // cannot move without energy
        // simple random movement to neighbouring tile
        const dx = Math.floor(Math.random() * 3) - 1;
        const dy = Math.floor(Math.random() * 3) - 1;
        const newX = Math.max(0, Math.min(cols - 1, this.x + dx));
        const newY = Math.max(0, Math.min(rows - 1, this.y + dy));
        this.x = newX;
        this.y = newY;
        this.energy -= 0.2; // moving costs energy
    }

    harvest() {
        const tileEnergy = energyGrid[this.y][this.x];
        if (tileEnergy > 0) {
            const gained = Math.min(1, tileEnergy);
            energyGrid[this.y][this.x] -= gained;
            this.energy += gained;
        }
    }

    reproduce(targetArray) {
        if (this.energy >= 10) {
            this.energy /= 2; // share energy with child
            const child = new Cell(this.x, this.y);
            child.energy = this.energy;
            targetArray.push(child);
        }
    }

    tick(targetArray) {
        this.move();
        this.harvest();
        this.reproduce(targetArray);
    }

    draw() {
        ctx.fillStyle = 'black';
        ctx.fillRect(this.x * cellSize, this.y * cellSize, cellSize, cellSize);
    }
}

function regenerateEnergy() {
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            energyGrid[y][x] = Math.min(maxTileEnergy, energyGrid[y][x] + regenRate);
        }
    }
}

function drawEnergy() {
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            const energy = energyGrid[y][x] / maxTileEnergy; // 0 to 1
            const color = `rgba(0, 255, 0, ${energy})`;
            ctx.fillStyle = color;
            ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
        }
    }
}

function step() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    regenerateEnergy();
    drawEnergy();

    // Work on a snapshot to avoid newly added cells acting this tick
    const snapshot = organisms.slice();
    const updatedOrganisms = [];

    for (const org of snapshot) {
        org.tick(updatedOrganisms);
        if (org.energy > 0) {
            updatedOrganisms.push(org);
            org.draw();
        }
    }

    // Replace the original array with the updated set of organisms
    organisms.length = 0;
    organisms.push(...updatedOrganisms);

    requestAnimationFrame(step);
}

// Seed initial cells
for (let i = 0; i < 10; i++) {
    organisms.push(new Cell(Math.floor(cols / 2), Math.floor(rows / 2)));
}

step();
</script>
</body>
</html>
