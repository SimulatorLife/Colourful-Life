<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Evolution Simulation</title>
  <style>
    canvas { display: block; margin: 0 auto; background: #000; }
  </style>
</head>
<body>
  <canvas id="sim" width="800" height="800"></canvas>
  <script>
    const canvas = document.getElementById('sim');
    const ctx = canvas.getContext('2d');
    const cellSize = 10;
    const rows = canvas.height / cellSize;
    const cols = canvas.width / cellSize;

    const colours = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
    const reproductionRate = 0.02;
    const geneMutationRange = 0.1;

    class Genes {
      constructor(weights) {
        this.weights = weights; // Array of numeric weights
      }
    }

    class Cell {
      constructor(row, col, genes) {
        this.row = row;
        this.col = col;
        this.genes = genes;
        this.updateColour();
      }

      updateColour() {
        const weight = Math.min(1, Math.max(0, this.genes.weights[0]));
        const index = Math.floor(weight * colours.length) % colours.length;
        this.colour = colours[index];
      }
    }

    const grid = Array.from({ length: rows }, () => Array(cols).fill(null));
    const cells = [];

    function randomGenes() {
      const weights = Array.from({ length: 3 }, () => Math.random());
      return new Genes(weights);
    }

    function combineGenes(a, b) {
      return a.weights.map((w, i) => (Math.random() < 0.5 ? w : b.weights[i]));
    }

    function mutateGenes(weights) {
      return weights.map(w => {
        const mutated = w + (Math.random() * 2 - 1) * geneMutationRange;
        return Math.min(1, Math.max(0, mutated));
      });
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      for (const cell of cells) {
        ctx.fillStyle = cell.colour;
        ctx.fillRect(cell.col * cellSize, cell.row * cellSize, cellSize, cellSize);
      }
    }

    function step() {
      const newCells = [];
      for (const cell of cells) {
        if (Math.random() < reproductionRate) {
          const neighbours = [];
          const empty = [];
          for (let dr = -1; dr <= 1; dr++) {
            for (let dc = -1; dc <= 1; dc++) {
              if (dr === 0 && dc === 0) continue;
              const r = (cell.row + dr + rows) % rows;
              const c = (cell.col + dc + cols) % cols;
              const occupant = grid[r][c];
              if (occupant) neighbours.push(occupant); else empty.push([r, c]);
            }
          }
          if (empty.length > 0) {
            const mate = neighbours.length > 0 ? neighbours[Math.floor(Math.random() * neighbours.length)] : null;
            let geneWeights = mate ? combineGenes(cell.genes, mate.genes) : [...cell.genes.weights];
            geneWeights = mutateGenes(geneWeights);
            const childGenes = new Genes(geneWeights);
            const [r, c] = empty[Math.floor(Math.random() * empty.length)];
            const child = new Cell(r, c, childGenes);
            grid[r][c] = child;
            newCells.push(child);
          }
        }
      }
      cells.push(...newCells);
      draw();
      requestAnimationFrame(step);
    }

    // initialise grid
    for (let i = 0; i < 100; i++) {
      const r = Math.floor(Math.random() * rows);
      const c = Math.floor(Math.random() * cols);
      if (!grid[r][c]) {
        const cell = new Cell(r, c, randomGenes());
        grid[r][c] = cell;
        cells.push(cell);
      }
    }

    draw();
    requestAnimationFrame(step);
  </script>
</body>
</html>
