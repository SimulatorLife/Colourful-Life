<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Colourful Life Simulation</title>
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <div id="app" class="app-layout">
      <canvas id="gameCanvas"></canvas>
    </div>
    <script type="module">
      import { randomRange, randomPercent } from './utils.js';
      import UIManager from './uiManager.js';
      import EventManager from './eventManager.js';
      import DNA from './genome.js';

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      canvas.width = 800;
      canvas.height = 800;
      const cellSize = 8;
      const rows = canvas.height / cellSize;
      const cols = canvas.width / cellSize;
      let lastUpdateTime = 0;

      const eventManager = new EventManager(rows, cols);

      // Population density helpers
      const DENSITY_RADIUS = 1; // Moore neighborhood radius for density calc
      const clamp = (x, min, max) => Math.max(min, Math.min(max, x));
      const lerp = (a, b, t) => a + (b - a) * (t < 0 ? 0 : t > 1 ? 1 : t);

      // Layout styles moved to styles.css

      class Cell {
        // TODO: The cells' colors should BE their genes. The RGB values should BE the DNA
        // Each value (0-255) represents genes that control behavior
        // Every one of the cell's preferences, inheritable traits, etc. is derived from these genes
        // This will make it easier to visualize evolution and relationships between cells: for any given cell, its color is a direct representation of its genetic code

        static baseEnergyLoss = 0.05;
        static chanceToMutate = 0.15;
        static geneMutationRange = 0.2;
        static minAge = 100;

        constructor(row, col, dna, energy) {
          this.row = row;
          this.col = col;
          this.dna = dna || DNA.random();
          this.genes = this.dna.weights();
          this.color = this.dna.toColor();
          this.age = 0;
          this.lifespan = this.dna.lifespan(Cell.maxAge, Cell.minAge);
          this.sight = this.dna.sight();
          this.energy = energy ?? this.dna.initialEnergy(GridManager.maxTileEnergy);
          this.neurons = this.dna.neurons();
          this.strategy = this.dna.strategy(); // Gene-controlled strategy for enemy encounters: 0..1: avoid, fight, cooperate
          this.movementGenes = this.dna.movementGenes();
          this.interactionGenes = this.dna.interactionGenes();
          this.density = this.dna.densityResponses();
        }

        /**
         * Create a new cell by combining traits from two parents.
         * The offspring inherits position, color, genes, and other
         * attributes from its parents with a chance for mutation.
         *
         * @param {Cell} parentA - First parent providing location and traits.
         * @param {Cell} parentB - Second parent contributing traits.
         * @returns {Cell} A new child cell placed at parentA's position.
         */
        static breed(parentA, parentB) {
          const row = parentA.row;
          const col = parentA.col;

          // Inherit and mutate DNA; all traits derive from DNA
          const chance = (parentA.dna.mutationChance() + parentB.dna.mutationChance()) / 2;
          const range = Math.round((parentA.dna.mutationRange() + parentB.dna.mutationRange()) / 2);
          const childDNA = parentA.dna.reproduceWith(parentB.dna, chance, range);
          const offspringEnergy = Math.max((parentA.energy + parentB.energy) / 2, 0.5);
          const offspring = new Cell(row, col, childDNA, offspringEnergy);
          const strategy =
            (parentA.strategy + parentB.strategy) / 2 +
            (Math.random() * Cell.geneMutationRange - Cell.geneMutationRange / 2);

          offspring.strategy = Math.min(1, Math.max(0, strategy));
          parentA.energy /= 2;
          parentB.energy /= 2;

          return offspring;
        }

        similarityTo(other) {
          return this.dna.similarity(other.dna);
        }

        static computeLifespan(genes) {
          const gene = genes?.[0]?.[0] ?? 0;
          const factor = Math.max(0, 1 + gene);

          return Math.round(600 * factor + randomRange(0, 600));
        }

        findBestMate(potentialMates) {
          let bestMate = null;
          let highestPreference = -Infinity;

          potentialMates.forEach((mate) => {
            const preference = this.similarityTo(mate.target);

            if (preference > highestPreference) {
              highestPreference = preference;
              bestMate = mate;
            }
          });

          return bestMate;
        }

        /**
         * Determine which action to take based on input signals from the
         * north, east, south, and west. Each potential action corresponds
         * to a row in `this.genes`, and its score is the dot product of the
         * row's weights with the input vector. The index of the highest
         * score is returned.
         *
         * @param {number} n - Stimulus from the northern neighbor.
         * @param {number} e - Stimulus from the eastern neighbor.
         * @param {number} s - Stimulus from the southern neighbor.
         * @param {number} w - Stimulus from the western neighbor.
         * @returns {number} Index of the selected action (0-5).
         */
        decide(n, e, s, w) {
          // Include a constant bias term plus directional inputs
          const inputs = [1, n, e, s, w];
          // Score each possible action by multiplying weights with inputs
          const scores = this.genes.map((weights) =>
            weights.reduce((sum, weight, idx) => sum + weight * inputs[idx], 0)
          );
          // Identify the index of the highest scoring action
          let max = scores[0];
          let index = 0;

          for (let i = 1; i < scores.length; i++) {
            if (scores[i] > max) {
              max = scores[i];
              index = i;
            }
          }

          return index; // Action index 0..5
        }

        decideMove() {
          // Simple uniform random cardinal move; could be refined via DNA
          const r = Math.floor(randomRange(0, 4));

          if (r === 0) return { dr: -1, dc: 0 };
          if (r === 1) return { dr: 1, dc: 0 };
          if (r === 2) return { dr: 0, dc: -1 };

          return { dr: 0, dc: 1 };
        }

        manageEnergy(row, col) {
          // Determine local population density using grid neighborhood
          const density = grid.localDensity(row, col, DENSITY_RADIUS);
          const effD = clamp(density * uiManager.getDensityEffectMultiplier(), 0, 1);

          // Use the last gene row as a simple metabolism indicator. Higher absolute
          // values increase the amount of energy consumed each tick.
          const geneRow = this.genes?.[5];
          const metabolism = Array.isArray(geneRow)
            ? geneRow.reduce((s, g) => s + Math.abs(g), 0) / (geneRow.length || 1)
            : Math.abs(Number(geneRow) || 0);

          // Base energy loss is scaled by metabolism, density via DNA response, and DNA metabolism scale.
          const energyDensityMult = lerp(
            this.density.energyLoss.min,
            this.density.energyLoss.max,
            effD
          );
          const energyLoss =
            Cell.baseEnergyLoss *
            this.dna.baseEnergyLossScale() *
            (1 + metabolism) *
            energyDensityMult;

          this.energy -= energyLoss;

          return this.energy <= this.starvationThreshold();
        }

        starvationThreshold() {
          return this.dna.starvationThresholdFrac() * GridManager.maxTileEnergy;
        }

        static randomMovementGenes() {
          return {
            wandering: randomRange(0, 1),
            pursuit: randomRange(0, 1),
            cautious: randomRange(0, 1),
          };
        }

        chooseMovementStrategy(localDensity = 0) {
          // DNA-based multipliers shift strategy with density
          let { wandering, pursuit, cautious } = this.movementGenes;
          const effD = clamp(localDensity * uiManager.getDensityEffectMultiplier(), 0, 1);
          const cautiousMul = lerp(this.density.cautious.min, this.density.cautious.max, effD);
          const pursuitMul = lerp(this.density.pursuit.max, this.density.pursuit.min, effD);
          const cautiousScaled = Math.max(0, cautious * cautiousMul);
          const pursuitScaled = Math.max(0, pursuit * pursuitMul);
          const wanderingScaled = Math.max(0, wandering);
          const total = wanderingScaled + pursuitScaled + cautiousScaled || 1;
          const r = randomRange(0, total);

          if (r < wanderingScaled) return 'wandering';
          if (r < wanderingScaled + pursuitScaled) return 'pursuit';

          return 'cautious';
        }

        executeMovementStrategy(gridArr, row, col, mates, enemies, society) {
          const localDensity = grid.localDensity(row, col, DENSITY_RADIUS);
          const strategy = this.chooseMovementStrategy(localDensity);

          if (strategy === 'pursuit' && society.length > 0) {
            const target = society[Math.floor(randomRange(0, society.length))];

            moveToTarget(gridArr, row, col, target.row, target.col);
          } else if (strategy === 'cautious' && society.length > 0) {
            const target = society[Math.floor(randomRange(0, society.length))];

            moveAwayFromTarget(gridArr, row, col, target.row, target.col);
          } else {
            moveRandomly(gridArr, row, col, this);
          }
        }
      }

      class GridManager {
        // Static properties
        static maxTileEnergy = 5;
        static energyRegenRate = 0.25;

        constructor(rows, cols) {
          this.rows = rows;
          this.cols = cols;
          this.grid = Array.from({ length: rows }, () => Array(cols).fill(null));
          this.energyGrid = Array.from({ length: rows }, () =>
            Array.from({ length: cols }, () => GridManager.maxTileEnergy / 2)
          );
          this.init();
        }

        init() {
          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              if (randomPercent(0.05)) {
                const dna = DNA.random();

                this.grid[row][col] = new Cell(row, col, dna);
              }
            }
          }
        }

        consumeEnergy(cell, row, col) {
          const available = this.energyGrid[row][col];
          const take = Math.min(1, available);

          this.energyGrid[row][col] -= take;
          cell.energy = Math.min(GridManager.maxTileEnergy, cell.energy + take);
        }

        regenerateEnergyGrid() {
          for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
              this.energyGrid[r][c] = Math.min(
                GridManager.maxTileEnergy,
                this.energyGrid[r][c] + GridManager.energyRegenRate
              );
            }
          }
        }

        getCell(row, col) {
          return this.grid[row][col];
        }
        setCell(row, col, cell) {
          this.grid[row][col] = cell;
        }

        // Compute local population density around (row,col) within a given radius
        localDensity(row, col, radius = 1) {
          let count = 0;
          let total = 0;

          for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
              if (dx === 0 && dy === 0) continue;
              const rr = (row + dy + this.rows) % this.rows;
              const cc = (col + dx + this.cols) % this.cols;

              total++;
              if (this.grid[rr][cc]) count++;
            }
          }

          return total > 0 ? count / total : 0;
        }

        draw() {
          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              const cell = this.getCell(row, col);

              if (cell) {
                ctx.fillStyle = cell.color;
                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
              } else {
                ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);
              }
            }
          }
          if (eventManager.currentEvent) {
            ctx.fillStyle = eventManager.getEventColor();
            ctx.fillRect(
              eventManager.currentEvent.affectedArea.x * cellSize,
              eventManager.currentEvent.affectedArea.y * cellSize,
              eventManager.currentEvent.affectedArea.width * cellSize,
              eventManager.currentEvent.affectedArea.height * cellSize
            );
          }
        }

        update() {
          // TODO: Break this function up into smaller functions & make it more readable
          const populationDensity = this.calculatePopulationDensity();
          const minPopulation = Math.floor(this.rows * this.cols * 0.05);
          const currentPopulation = Math.floor(populationDensity * this.rows * this.cols);

          seed(currentPopulation, minPopulation);

          const highDensity = populationDensity > 0.5 + randomRange(0, 0.2); // kept for global mood

          this.regenerateEnergyGrid();
          eventManager.updateEvent();

          const processed = new WeakSet();

          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              const cell = this.grid[row][col];

              if (!cell || processed.has(cell)) continue;
              processed.add(cell);

              cell.age++;
              if (cell.age >= cell.lifespan) {
                this.grid[row][col] = null;
                continue;
              }

              applyEventEffects(cell, row, col, eventManager.currentEvent);
              this.consumeEnergy(cell, row, col);
              cell.manageEnergy(row, col);
              if (cell.energy <= 0) {
                this.grid[row][col] = null;
                continue;
              }

              const { mates, enemies, society } = this.findTargets(row, col, cell, highDensity);

              if (mates.length > 0) {
                const bestMate = cell.findBestMate(mates);

                if (bestMate) {
                  moveToTarget(this.grid, row, col, bestMate.row, bestMate.col);
                  const baseReproProb =
                    (cell.dna.reproductionProb() + bestMate.target.dna.reproductionProb()) / 2;
                  const localDensity = this.localDensity(row, col, DENSITY_RADIUS);
                  // Reproduction multiplier decreases with density: use max at d=0, min at d=1
                  const effD = clamp(localDensity * uiManager.getDensityEffectMultiplier(), 0, 1);
                  const reproMul = lerp(
                    cell.density.reproduction.max,
                    cell.density.reproduction.min,
                    effD
                  );
                  const reproProb = clamp(baseReproProb * reproMul, 0.01, 0.95);

                  if (
                    randomPercent(reproProb) &&
                    cell.energy >= 0.5 &&
                    bestMate.target.energy >= 0.5
                  ) {
                    const offspring = Cell.breed(cell, bestMate.target);

                    this.grid[row][col] = offspring;
                  }
                }
              } else if (enemies.length > 0) {
                const targetEnemy = enemies[Math.floor(randomRange(0, enemies.length))];
                // Choose interaction by DNA interaction genes
                const { avoid, fight, cooperate } = cell.interactionGenes;
                const localDensity = this.localDensity(row, col, DENSITY_RADIUS);
                const effD = clamp(localDensity * uiManager.getDensityEffectMultiplier(), 0, 1);
                const fightMul = lerp(cell.density.fight.min, cell.density.fight.max, effD);
                const coopMul = lerp(cell.density.cooperate.max, cell.density.cooperate.min, effD);
                const fightW = Math.max(0.0001, fight * fightMul);
                const coopW = Math.max(0.0001, cooperate * coopMul);
                const avoidW = Math.max(0.0001, avoid);
                const total = avoidW + fightW + coopW;
                const roll = randomRange(0, total);

                if (roll < avoidW) {
                  moveAwayFromTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                } else if (roll < avoidW + fightW) {
                  const dist = Math.max(
                    Math.abs(targetEnemy.row - row),
                    Math.abs(targetEnemy.col - col)
                  );

                  if (dist <= 1) fightEnemy(this, row, col, targetEnemy.row, targetEnemy.col);
                  else moveToTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                } else {
                  const dist = Math.max(
                    Math.abs(targetEnemy.row - row),
                    Math.abs(targetEnemy.col - col)
                  );

                  if (dist <= 1)
                    cooperateWithEnemy(this, row, col, targetEnemy.row, targetEnemy.col);
                  else moveToTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                }
              } else {
                // Use DNA-driven movement strategy when idle
                cell.executeMovementStrategy(this.grid, row, col, mates, enemies, society || []);
              }
            }
          }
        }

        calculatePopulationDensity() {
          let population = 0;

          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              if (this.grid[row][col]) {
                population++;
              }
            }
          }

          return population / (this.rows * this.cols);
        }

        findTargets(row, col, cell) {
          const mates = [];
          const enemies = [];
          const society = [];
          const d = this.localDensity(row, col, DENSITY_RADIUS);
          const effD = clamp(d * uiManager.getDensityEffectMultiplier(), 0, 1);
          const enemyBias = lerp(cell.density.enemyBias.min, cell.density.enemyBias.max, effD);

          for (let x = -cell.sight; x <= cell.sight; x++) {
            for (let y = -cell.sight; y <= cell.sight; y++) {
              if (x === 0 && y === 0) continue;
              const newRow = (row + y + this.rows) % this.rows;
              const newCol = (col + x + this.cols) % this.cols;
              const target = this.grid[newRow][newCol];

              if (target) {
                const similarity = cell.similarityTo(target);

                if (similarity >= uiManager.getSocietySimilarity()) {
                  society.push({ row: newRow, col: newCol, target });
                } else if (
                  similarity <= uiManager.getEnemySimilarity() ||
                  randomPercent(enemyBias)
                ) {
                  enemies.push({ row: newRow, col: newCol, target });
                } else {
                  mates.push({ row: newRow, col: newCol, target });
                }
              }
            }
          }

          return { mates, enemies, society };
        }
      }

      // TODO: Lots of the following methods should be moved to the Cell, EventManager, or GridManager classes

      /*
       * Seed new cells if the population drops below a minimum threshold
       */
      function seed(currentPopulation, minPopulation) {
        if (currentPopulation >= minPopulation) return;

        const empty = [];

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (!grid.getCell(r, c)) empty.push({ r, c });
          }
        }

        const toSeed = Math.min(minPopulation - currentPopulation, empty.length);

        for (let i = 0; i < toSeed; i++) {
          const idx = Math.floor(randomRange(0, empty.length));
          const { r, c } = empty.splice(idx, 1)[0];
          const dna = DNA.random();
          const newCell = new Cell(r, c, dna);

          grid.setCell(r, c, newCell);
        }
      }

      /**
       * Move a cell in the grid from (sr, sc) to (dr, dc)
       */
      function tryMove(gridArr, sr, sc, dr, dc) {
        const nr = (sr + dr + rows) % rows;
        const nc = (sc + dc + cols) % cols;
        const dcell = gridArr[nr][nc];

        if (!dcell) {
          // Check if the destination cell is empty
          gridArr[nr][nc] = gridArr[sr][sc];
          gridArr[sr][sc] = null;

          return true;
        }

        return false;
      }

      function moveToTarget(gridArr, row, col, targetRow, targetCol) {
        const dRow = targetRow - row;
        const dCol = targetCol - col;
        let dr = 0,
          dc = 0;

        if (Math.abs(dRow) >= Math.abs(dCol)) dr = Math.sign(dRow);
        else dc = Math.sign(dCol);

        return tryMove(gridArr, row, col, dr, dc);
      }

      function moveAwayFromTarget(gridArr, row, col, targetRow, targetCol) {
        const dRow = targetRow - row;
        const dCol = targetCol - col;
        let dr = 0,
          dc = 0;

        if (Math.abs(dRow) >= Math.abs(dCol)) dr = -Math.sign(dRow);
        else dc = -Math.sign(dCol);

        return tryMove(gridArr, row, col, dr, dc);
      }

      function moveRandomly(gridArr, row, col, cell) {
        const { dr, dc } = cell.decideMove();

        return tryMove(gridArr, row, col, dr, dc);
      }

      function fightEnemy(manager, attackerRow, attackerCol, targetRow, targetCol) {
        const attacker = manager.grid[attackerRow][attackerCol];
        const defender = manager.grid[targetRow][targetCol];

        if (!defender) return;
        if (attacker.energy >= defender.energy) {
          manager.grid[targetRow][targetCol] = attacker;
          manager.grid[attackerRow][attackerCol] = null;
          manager.consumeEnergy(attacker, targetRow, targetCol);
        } else {
          manager.grid[attackerRow][attackerCol] = null;
        }
      }

      function cooperateWithEnemy(manager, row, col, targetRow, targetCol) {
        const cell = manager.grid[row][col];
        const partner = manager.grid[targetRow][targetCol];

        if (!partner) return;
        const share = Math.min(1, cell.energy / 2);

        cell.energy -= share;
        partner.energy = Math.min(GridManager.maxTileEnergy, partner.energy + share);
      }

      function applyEventEffects(cell, row, col, currentEvent) {
        if (
          currentEvent &&
          row >= currentEvent.affectedArea.y &&
          row < currentEvent.affectedArea.y + currentEvent.affectedArea.height &&
          col >= currentEvent.affectedArea.x &&
          col < currentEvent.affectedArea.x + currentEvent.affectedArea.width
        ) {
          const s = currentEvent.strength * uiManager.getEventStrengthMultiplier();

          switch (currentEvent.eventType) {
            case 'flood': {
              const resist = cell.dna.floodResist();

              cell.energy -= 0.3 * s * (1 - resist);
              break;
            }
            case 'drought': {
              const resist = cell.dna.droughtResist();

              cell.energy -= 0.25 * s * (1 - resist);
              break;
            }
            case 'heatwave': {
              const resist = cell.dna.heatResist();

              cell.energy -= 0.35 * s * (1 - resist);
              break;
            }
            case 'coldwave': {
              const resist = cell.dna.coldResist();

              cell.energy -= 0.2 * s * (1 - resist);
              break;
            }
          }
          cell.energy = Math.max(0, Math.min(GridManager.maxTileEnergy, cell.energy));
        }
      }

      function update() {
        if (uiManager.isPaused()) {
          return;
        }

        const now = performance.now();
        const interval = 1000 / Math.max(1, uiManager.getUpdatesPerSecond());

        if (now - lastUpdateTime >= interval) {
          lastUpdateTime = now;
          grid.update();
        }
        grid.draw();
        requestAnimationFrame(update);
      }

      // Create grid and UI
      const grid = new GridManager(rows, cols);
      const uiManager = new UIManager(update, '#app');

      requestAnimationFrame(update);
    </script>
  </body>
</html>
