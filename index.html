<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Colourful Life Simulation</title>
    <style>
      canvas {
        display: block;
        margin: 0 auto;
        background-color: #000;
      }

      body {
        background-color: #222;
      }
    </style>
  </head>

  <body>
    <div id="app" class="app-layout">
      <canvas id="gameCanvas"></canvas>
    </div>
    <script type="module">
      import { randomRange, randomPercent, createRNG } from './utils.js';
      import UIManager from './uiManager.js';
      import EventManager from './eventManager.js';

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      canvas.width = 800;
      canvas.height = 800;
      const cellSize = 8;
      const rows = canvas.height / cellSize;
      const cols = canvas.width / cellSize;
      let lastUpdateTime = 0;

      const eventManager = new EventManager(rows, cols);

      // Population density helpers
      const DENSITY_RADIUS = 1; // Moore neighborhood radius for density calc
      const clamp = (x, min, max) => Math.max(min, Math.min(max, x));
      const lerp = (a, b, t) => a + (b - a) * (t < 0 ? 0 : t > 1 ? 1 : t);

      // (Controls moved into UIManager)
      // Layout styles
      const style = document.createElement('style');

      style.textContent = `
        .app-layout { display: flex; gap: 12px; max-width: 1200px; margin: 8px auto; align-items: flex-start; }
        #gameCanvas { flex: 1 1 auto; box-shadow: 0 0 0 1px #111; }
        .controls-panel { width: 300px; color: #ddd; font-family: sans-serif; background: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 12px; position: sticky; top: 8px; max-height: calc(100vh - 16px); overflow: auto; }
        .controls-panel h3 { margin: 0 0 8px; font-size: 16px; color: #eee; }
        .controls-panel button { width: 100%; margin-bottom: 10px; padding: 6px 10px; background: #2b2b2b; color: #eee; border: 1px solid #444; border-radius: 4px; cursor: pointer; }
        .controls-panel button:hover { background: #333; }
        .control-row { display: block; margin: 10px 0; cursor: default; }
        .control-name { font-size: 12px; color: #bbb; margin-bottom: 4px; }
        .control-line { display: flex; align-items: center; gap: 8px; }
        .control-line input[type="range"] { flex: 1 1 auto; }
        .control-value { min-width: 42px; text-align: right; color: #aaa; font-variant-numeric: tabular-nums; }
      `;
      document.head.appendChild(style);

      class DNA {
        constructor(r, g, b) {
          this.r = r | 0;
          this.g = g | 0;
          this.b = b | 0;
        }

        prng() {
          return createRNG(this.seed());
        }

        // Deterministic per-trait RNG stream derived from DNA seed
        prngFor(tag) {
          let h = (this.seed() ^ 2166136261) >>> 0; // FNV-1a start xor seed

          for (let i = 0; i < tag.length; i++) {
            h ^= tag.charCodeAt(i);
            h = Math.imul(h, 16777619) >>> 0;
          }

          return createRNG(h >>> 0);
        }

        static random(rng = Math.random) {
          return new DNA(
            Math.floor(rng() * 256), // r
            Math.floor(rng() * 256), // g
            Math.floor(rng() * 256) // b
          );
        }

        toColor() {
          return `rgb(${this.r},${this.g},${this.b})`;
        }

        seed() {
          return (this.r | (this.g << 8) | (this.b << 16)) >>> 0;
        }

        // Expand RGB genome to a 6x5 weight matrix in [-1,1]
        weights() {
          const rnd = this.prngFor('weights');
          const rows = [];

          for (let a = 0; a < 6; a++) {
            const row = [];

            for (let i = 0; i < 5; i++) {
              row.push(rnd() * 2 - 1);
            }
            rows.push(row);
          }

          return rows;
        }

        movementGenes() {
          const rnd = this.prngFor('movementGenes');

          return {
            wandering: rnd(),
            pursuit: rnd(),
            cautious: rnd(),
          };
        }

        interactionGenes() {
          const rnd = this.prngFor('interactionGenes');

          return { avoid: rnd(), fight: rnd(), cooperate: rnd() };
        }

        reproductionProb() {
          const rnd = this.prngFor('reproductionProb');
          // Bias by green channel (resource affinity): 0.2..0.6
          const base = 0.2 + (this.g / 255) * 0.4;

          // small deterministic jitter
          return Math.min(0.8, Math.max(0.05, base * (0.9 + rnd() * 0.2)));
        }

        initialEnergy(maxEnergy = 5) {
          const brightness = (this.r + this.g + this.b) / (3 * 255);

          return Math.max(0.5, Math.min(maxEnergy, 0.5 + brightness * (maxEnergy - 0.5)));
        }

        lifespan(maxAge = 1000) {
          // Map blue to longer life; add small deterministic variation
          const rnd = this.prngFor('lifespan');
          const base = 0.5 + (this.b / 255) * 0.5; // 0.5..1.0 of maxAge
          const lifespanAdj = ((this.b - 127.5) / 255) * 100;

          return Math.max(
            Cell.minAge,
            Math.round(maxAge * (base * (0.95 + rnd() * 0.1))) + lifespanAdj
          );
        }

        floodResist() {
          return this.b / 255;
        }

        heatResist() {
          return this.r / 255;
        }

        droughtResist() {
          return this.g / 255;
        }

        coldResist() {
          return (this.g + this.b) / (2 * 255);
        }

        mutationChance() {
          const rnd = this.prngFor('mutationChance');

          return 0.08 + rnd() * 0.2; // 0.08..0.28
        }

        mutationRange() {
          const rnd = this.prngFor('mutationRange');

          return 6 + Math.floor(rnd() * 20); // 6..25
        }

        starvationThresholdFrac() {
          // Higher green -> better resource efficiency, lower threshold
          // Map to 0.2..0.8
          return 0.8 - (this.g / 255) * 0.6;
        }

        neurons() {
          const rnd = this.prngFor('neurons');

          return Math.max(1, Math.floor(rnd() * 5) + 1);
        }

        sight() {
          const rnd = this.prngFor('sight');

          return Math.max(1, Math.floor(rnd() * 5) + 1);
        }

        baseEnergyLossScale() {
          // Higher brightness -> higher metabolism
          const brightness = (this.r + this.g + this.b) / (3 * 255);

          return 0.5 + brightness; // 0.5..1.5 scale
        }

        strategy() {
          const rnd = this.prngFor('strategy');

          return rnd(); // 0..1
        }

        lifespanAdj() {
          // Map blue channel to lifespan adjustment roughly -50..+50
          return ((this.b - 127.5) / 255) * 100;
        }

        // DNA-driven min/max multipliers for density effects
        densityResponses() {
          const r = this.r / 255;
          const g = this.g / 255;
          const b = this.b / 255;
          const brightness = (this.r + this.g + this.b) / (3 * 255);

          // Reproduction multiplier decreases with density
          const reproMax = 1.0 + g * 0.3; // d=0
          const reproMin = 0.3 + g * 0.4; // d=1

          // Fight multiplier increases with density
          const fightMin = 0.8 + r * 0.3; // d=0
          const fightMax = 1.3 + r * 0.9; // d=1

          // Cooperation multiplier decreases with density (blue mitigates drop)
          const coopMax = 1.1 + b * 0.2; // d=0
          const coopMin = 0.5 + b * 0.4; // d=1

          // Energy loss multiplier increases with density (less green -> more penalty)
          const energyMin = 1.0 + brightness * 0.2; // d=0
          const energyMax = 1.1 + (1 - g) * 0.6; // d=1

          // Movement weighting
          const cautiousMin = 1.0 + b * 0.2; // d=0
          const cautiousMax = 1.2 + b * 0.8; // d=1
          const pursuitMax = 1.0 + r * 0.2; // d=0
          const pursuitMin = 0.6 + (1 - b) * 0.4; // d=1

          // Probability to classify neutral as enemy
          const enemyBiasMin = 0.02 + r * 0.08; // d=0
          const enemyBiasMax = 0.2 + r * 0.5; // d=1

          return {
            reproduction: { min: reproMin, max: reproMax },
            fight: { min: fightMin, max: fightMax },
            cooperate: { min: coopMin, max: coopMax },
            energyLoss: { min: energyMin, max: energyMax },
            cautious: { min: cautiousMin, max: cautiousMax },
            pursuit: { min: pursuitMin, max: pursuitMax },
            enemyBias: { min: enemyBiasMin, max: enemyBiasMax },
          };
        }

        reproduceWith(other, mutationChance = 0.15, mutationRange = 12) {
          const mix = (a, b) => {
            let v = Math.round((a + b) / 2);

            if (randomPercent(mutationChance)) {
              v += Math.floor(randomRange(-1, 1) * mutationRange);
            }

            return Math.max(0, Math.min(255, v));
          };

          return new DNA(mix(this.r, other.r), mix(this.g, other.g), mix(this.b, other.b));
        }
        similarity(other) {
          const dx = this.r - other.r,
            dy = this.g - other.g,
            dz = this.b - other.b;
          const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
          const maxDist = Math.sqrt(3 * 255 * 255);

          return 1 - dist / maxDist;
        }
      }

      class Cell {
        // TODO: The cells' colors should BE their genes. The RGB values should BE the DNA
        // Each value (0-255) represents genes that control behavior
        // Every one of the cell's preferences, inheritable traits, etc. is derived from these genes
        // This will make it easier to visualize evolution and relationships between cells: for any given cell, its color is a direct representation of its genetic code

        static baseEnergyLoss = 0.05;
        static chanceToMutate = 0.15;
        static geneMutationRange = 0.2;
        static minAge = 100;

        constructor(row, col, dna, energy) {
          this.row = row;
          this.col = col;
          this.dna = dna || DNA.random();
          this.genes = this.dna.weights();
          this.color = this.dna.toColor();
          this.age = 0;
          this.lifespan = this.dna.lifespan(Cell.maxAge);
          this.sight = this.dna.sight();
          this.energy = energy ?? this.dna.initialEnergy(GridManager.maxTileEnergy);
          this.neurons = this.dna.neurons();
          this.strategy = this.dna.strategy(); // Gene-controlled strategy for enemy encounters: 0..1: avoid, fight, cooperate
          this.movementGenes = this.dna.movementGenes();
          this.interactionGenes = this.dna.interactionGenes();
          this.density = this.dna.densityResponses();
        }

        /**
         * Create a new cell by combining traits from two parents.
         * The offspring inherits position, color, genes, and other
         * attributes from its parents with a chance for mutation.
         *
         * @param {Cell} parentA - First parent providing location and traits.
         * @param {Cell} parentB - Second parent contributing traits.
         * @returns {Cell} A new child cell placed at parentA's position.
         */
        static breed(parentA, parentB) {
          const row = parentA.row;
          const col = parentA.col;

          // Inherit and mutate DNA; all traits derive from DNA
          const chance = (parentA.dna.mutationChance() + parentB.dna.mutationChance()) / 2;
          const range = Math.round((parentA.dna.mutationRange() + parentB.dna.mutationRange()) / 2);
          const childDNA = parentA.dna.reproduceWith(parentB.dna, chance, range);
          const offspringEnergy = Math.max((parentA.energy + parentB.energy) / 2, 0.5);
          const offspring = new Cell(row, col, childDNA, offspringEnergy);
          const strategy =
            (parentA.strategy + parentB.strategy) / 2 +
            (Math.random() * Cell.geneMutationRange - Cell.geneMutationRange / 2);

          offspring.strategy = Math.min(1, Math.max(0, strategy));
          parentA.energy /= 2;
          parentB.energy /= 2;

          return offspring;
        }

        similarityTo(other) {
          return this.dna.similarity(other.dna);
        }

        static computeLifespan(genes) {
          const gene = genes?.[0]?.[0] ?? 0;
          const factor = Math.max(0, 1 + gene);

          return Math.round(600 * factor + randomRange(0, 600));
        }

        findBestMate(potentialMates) {
          let bestMate = null;
          let highestPreference = -Infinity;

          potentialMates.forEach((mate) => {
            const preference = this.similarityTo(mate.target);

            if (preference > highestPreference) {
              highestPreference = preference;
              bestMate = mate;
            }
          });

          return bestMate;
        }

        /**
         * Determine which action to take based on input signals from the
         * north, east, south, and west. Each potential action corresponds
         * to a row in `this.genes`, and its score is the dot product of the
         * row's weights with the input vector. The index of the highest
         * score is returned.
         *
         * @param {number} n - Stimulus from the northern neighbor.
         * @param {number} e - Stimulus from the eastern neighbor.
         * @param {number} s - Stimulus from the southern neighbor.
         * @param {number} w - Stimulus from the western neighbor.
         * @returns {number} Index of the selected action (0-5).
         */
        decide(n, e, s, w) {
          // Include a constant bias term plus directional inputs
          const inputs = [1, n, e, s, w];
          // Score each possible action by multiplying weights with inputs
          const scores = this.genes.map((weights) =>
            weights.reduce((sum, weight, idx) => sum + weight * inputs[idx], 0)
          );
          // Identify the index of the highest scoring action
          let max = scores[0];
          let index = 0;

          for (let i = 1; i < scores.length; i++) {
            if (scores[i] > max) {
              max = scores[i];
              index = i;
            }
          }

          return index; // Action index 0..5
        }

        decideMove() {
          // Simple uniform random cardinal move; could be refined via DNA
          const r = Math.floor(randomRange(0, 4));

          if (r === 0) return { dr: -1, dc: 0 };
          if (r === 1) return { dr: 1, dc: 0 };
          if (r === 2) return { dr: 0, dc: -1 };

          return { dr: 0, dc: 1 };
        }

        manageEnergy(row, col) {
          // Determine local population density using grid neighborhood
          const density = grid.localDensity(row, col, DENSITY_RADIUS);

          // Use the last gene row as a simple metabolism indicator. Higher absolute
          // values increase the amount of energy consumed each tick.
          const geneRow = this.genes?.[5];
          const metabolism = Array.isArray(geneRow)
            ? geneRow.reduce((s, g) => s + Math.abs(g), 0) / (geneRow.length || 1)
            : Math.abs(Number(geneRow) || 0);

          // Base energy loss is scaled by metabolism, density via DNA response, and DNA metabolism scale.
          const energyDensityMult = lerp(
            this.density.energyLoss.min,
            this.density.energyLoss.max,
            density
          );
          const energyLoss =
            Cell.baseEnergyLoss *
            this.dna.baseEnergyLossScale() *
            (1 + metabolism) *
            energyDensityMult;

          this.energy -= energyLoss;

          return this.energy <= this.starvationThreshold();
        }

        starvationThreshold() {
          return this.dna.starvationThresholdFrac() * GridManager.maxTileEnergy;
        }

        static randomMovementGenes() {
          return {
            wandering: randomRange(0, 1),
            pursuit: randomRange(0, 1),
            cautious: randomRange(0, 1),
          };
        }

        chooseMovementStrategy(localDensity = 0) {
          // DNA-based multipliers shift strategy with density
          let { wandering, pursuit, cautious } = this.movementGenes;
          const cautiousMul = lerp(
            this.density.cautious.min,
            this.density.cautious.max,
            localDensity
          );
          const pursuitMul = lerp(this.density.pursuit.max, this.density.pursuit.min, localDensity);
          const cautiousScaled = Math.max(0, cautious * cautiousMul);
          const pursuitScaled = Math.max(0, pursuit * pursuitMul);
          const wanderingScaled = Math.max(0, wandering);
          const total = wanderingScaled + pursuitScaled + cautiousScaled || 1;
          const r = randomRange(0, total);

          if (r < wanderingScaled) return 'wandering';
          if (r < wanderingScaled + pursuitScaled) return 'pursuit';

          return 'cautious';
        }

        executeMovementStrategy(gridArr, row, col, mates, enemies, society) {
          const localDensity = grid.localDensity(row, col, DENSITY_RADIUS);
          const strategy = this.chooseMovementStrategy(localDensity);

          if (strategy === 'pursuit' && society.length > 0) {
            const target = society[Math.floor(randomRange(0, society.length))];

            moveToTarget(gridArr, row, col, target.row, target.col);
          } else if (strategy === 'cautious' && society.length > 0) {
            const target = society[Math.floor(randomRange(0, society.length))];

            moveAwayFromTarget(gridArr, row, col, target.row, target.col);
          } else {
            moveRandomly(gridArr, row, col, this);
          }
        }
      }

      class GridManager {
        // Static properties
        static maxTileEnergy = 5;
        static energyRegenRate = 0.25;

        constructor(rows, cols) {
          this.rows = rows;
          this.cols = cols;
          this.grid = Array.from({ length: rows }, () => Array(cols).fill(null));
          this.energyGrid = Array.from({ length: rows }, () =>
            Array.from({ length: cols }, () => GridManager.maxTileEnergy / 2)
          );
          this.init();
        }

        init() {
          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              if (randomPercent(0.05)) {
                const dna = DNA.random();

                this.grid[row][col] = new Cell(row, col, dna);
              }
            }
          }
        }

        consumeEnergy(cell, row, col) {
          const available = this.energyGrid[row][col];
          const take = Math.min(1, available);

          this.energyGrid[row][col] -= take;
          cell.energy = Math.min(GridManager.maxTileEnergy, cell.energy + take);
        }

        regenerateEnergyGrid() {
          for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
              this.energyGrid[r][c] = Math.min(
                GridManager.maxTileEnergy,
                this.energyGrid[r][c] + GridManager.energyRegenRate
              );
            }
          }
        }

        getCell(row, col) {
          return this.grid[row][col];
        }
        setCell(row, col, cell) {
          this.grid[row][col] = cell;
        }

        // Compute local population density around (row,col) within a given radius
        localDensity(row, col, radius = 1) {
          let count = 0;
          let total = 0;

          for (let dx = -radius; dx <= radius; dx++) {
            for (let dy = -radius; dy <= radius; dy++) {
              if (dx === 0 && dy === 0) continue;
              const rr = (row + dy + this.rows) % this.rows;
              const cc = (col + dx + this.cols) % this.cols;

              total++;
              if (this.grid[rr][cc]) count++;
            }
          }

          return total > 0 ? count / total : 0;
        }

        draw() {
          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              const cell = this.getCell(row, col);

              if (cell) {
                ctx.fillStyle = cell.color;
                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
              } else {
                ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);
              }
            }
          }
          if (eventManager.currentEvent) {
            ctx.fillStyle = eventManager.getEventColor();
            ctx.fillRect(
              eventManager.currentEvent.affectedArea.x * cellSize,
              eventManager.currentEvent.affectedArea.y * cellSize,
              eventManager.currentEvent.affectedArea.width * cellSize,
              eventManager.currentEvent.affectedArea.height * cellSize
            );
          }
        }

        update() {
          // TODO: Break this function up into smaller functions & make it more readable
          const populationDensity = this.calculatePopulationDensity();
          const minPopulation = Math.floor(this.rows * this.cols * 0.05);
          const currentPopulation = Math.floor(populationDensity * this.rows * this.cols);

          seed(currentPopulation, minPopulation);

          const highDensity = populationDensity > 0.5 + randomRange(0, 0.2); // kept for global mood

          this.regenerateEnergyGrid();
          eventManager.updateEvent();

          const processed = new WeakSet();

          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              const cell = this.grid[row][col];

              if (!cell || processed.has(cell)) continue;
              processed.add(cell);

              cell.age++;
              if (cell.age >= cell.lifespan) {
                this.grid[row][col] = null;
                continue;
              }

              applyEventEffects(cell, row, col, eventManager.currentEvent);
              this.consumeEnergy(cell, row, col);
              cell.manageEnergy(row, col);
              if (cell.energy <= 0) {
                this.grid[row][col] = null;
                continue;
              }

              const { mates, enemies, society } = this.findTargets(row, col, cell, highDensity);

              if (mates.length > 0) {
                const bestMate = cell.findBestMate(mates);

                if (bestMate) {
                  moveToTarget(this.grid, row, col, bestMate.row, bestMate.col);
                  const baseReproProb =
                    (cell.dna.reproductionProb() + bestMate.target.dna.reproductionProb()) / 2;
                  const localDensity = this.localDensity(row, col, DENSITY_RADIUS);
                  // Reproduction multiplier decreases with density: use max at d=0, min at d=1
                  const reproMul = lerp(
                    cell.density.reproduction.max,
                    cell.density.reproduction.min,
                    localDensity
                  );
                  const reproProb = clamp(baseReproProb * reproMul, 0.01, 0.95);

                  if (
                    randomPercent(reproProb) &&
                    cell.energy >= 0.5 &&
                    bestMate.target.energy >= 0.5
                  ) {
                    const offspring = Cell.breed(cell, bestMate.target);

                    this.grid[row][col] = offspring;
                  }
                }
              } else if (enemies.length > 0) {
                const targetEnemy = enemies[Math.floor(randomRange(0, enemies.length))];
                // Choose interaction by DNA interaction genes
                const { avoid, fight, cooperate } = cell.interactionGenes;
                const localDensity = this.localDensity(row, col, DENSITY_RADIUS);
                const fightMul = lerp(cell.density.fight.min, cell.density.fight.max, localDensity);
                const coopMul = lerp(
                  cell.density.cooperate.max,
                  cell.density.cooperate.min,
                  localDensity
                );
                const fightW = Math.max(0.0001, fight * fightMul);
                const coopW = Math.max(0.0001, cooperate * coopMul);
                const avoidW = Math.max(0.0001, avoid);
                const total = avoidW + fightW + coopW;
                const roll = randomRange(0, total);

                if (roll < avoidW) {
                  moveAwayFromTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                } else if (roll < avoidW + fightW) {
                  const dist = Math.max(
                    Math.abs(targetEnemy.row - row),
                    Math.abs(targetEnemy.col - col)
                  );

                  if (dist <= 1) fightEnemy(this, row, col, targetEnemy.row, targetEnemy.col);
                  else moveToTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                } else {
                  const dist = Math.max(
                    Math.abs(targetEnemy.row - row),
                    Math.abs(targetEnemy.col - col)
                  );

                  if (dist <= 1)
                    cooperateWithEnemy(this, row, col, targetEnemy.row, targetEnemy.col);
                  else moveToTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                }
              } else {
                // Use DNA-driven movement strategy when idle
                cell.executeMovementStrategy(this.grid, row, col, mates, enemies, society || []);
              }
            }
          }
        }

        calculatePopulationDensity() {
          let population = 0;

          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              if (this.grid[row][col]) {
                population++;
              }
            }
          }

          return population / (this.rows * this.cols);
        }

        findTargets(row, col, cell) {
          const mates = [];
          const enemies = [];
          const society = [];
          const d = this.localDensity(row, col, DENSITY_RADIUS);
          const enemyBias = lerp(cell.density.enemyBias.min, cell.density.enemyBias.max, d);

          for (let x = -cell.sight; x <= cell.sight; x++) {
            for (let y = -cell.sight; y <= cell.sight; y++) {
              if (x === 0 && y === 0) continue;
              const newRow = (row + y + this.rows) % this.rows;
              const newCol = (col + x + this.cols) % this.cols;
              const target = this.grid[newRow][newCol];

              if (target) {
                const similarity = cell.similarityTo(target);

                if (similarity >= uiManager.getSocietySimilarity()) {
                  society.push({ row: newRow, col: newCol, target });
                } else if (
                  similarity <= uiManager.getEnemySimilarity() ||
                  randomPercent(enemyBias)
                ) {
                  enemies.push({ row: newRow, col: newCol, target });
                } else {
                  mates.push({ row: newRow, col: newCol, target });
                }
              }
            }
          }

          return { mates, enemies, society };
        }
      }

      // TODO: Lots of the following methods should be moved to the Cell, EventManager, or GridManager classes

      /*
       * Seed new cells if the population drops below a minimum threshold
       */
      function seed(currentPopulation, minPopulation) {
        if (currentPopulation >= minPopulation) return;

        const empty = [];

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (!grid.getCell(r, c)) empty.push({ r, c });
          }
        }

        const toSeed = Math.min(minPopulation - currentPopulation, empty.length);

        for (let i = 0; i < toSeed; i++) {
          const idx = Math.floor(randomRange(0, empty.length));
          const { r, c } = empty.splice(idx, 1)[0];
          const dna = DNA.random();
          const newCell = new Cell(r, c, dna);

          grid.setCell(r, c, newCell);
        }
      }

      /**
       * Move a cell in the grid from (sr, sc) to (dr, dc)
       */
      function tryMove(gridArr, sr, sc, dr, dc) {
        const nr = (sr + dr + rows) % rows;
        const nc = (sc + dc + cols) % cols;
        const dcell = gridArr[nr][nc];

        if (!dcell) {
          // Check if the destination cell is empty
          gridArr[nr][nc] = gridArr[sr][sc];
          gridArr[sr][sc] = null;

          return true;
        }

        return false;
      }

      function moveToTarget(gridArr, row, col, targetRow, targetCol) {
        const dRow = targetRow - row;
        const dCol = targetCol - col;
        let dr = 0,
          dc = 0;

        if (Math.abs(dRow) >= Math.abs(dCol)) dr = Math.sign(dRow);
        else dc = Math.sign(dCol);

        return tryMove(gridArr, row, col, dr, dc);
      }

      function moveAwayFromTarget(gridArr, row, col, targetRow, targetCol) {
        const dRow = targetRow - row;
        const dCol = targetCol - col;
        let dr = 0,
          dc = 0;

        if (Math.abs(dRow) >= Math.abs(dCol)) dr = -Math.sign(dRow);
        else dc = -Math.sign(dCol);

        return tryMove(gridArr, row, col, dr, dc);
      }

      function moveRandomly(gridArr, row, col, cell) {
        const { dr, dc } = cell.decideMove();

        return tryMove(gridArr, row, col, dr, dc);
      }

      function fightEnemy(manager, attackerRow, attackerCol, targetRow, targetCol) {
        const attacker = manager.grid[attackerRow][attackerCol];
        const defender = manager.grid[targetRow][targetCol];

        if (!defender) return;
        if (attacker.energy >= defender.energy) {
          manager.grid[targetRow][targetCol] = attacker;
          manager.grid[attackerRow][attackerCol] = null;
          manager.consumeEnergy(attacker, targetRow, targetCol);
        } else {
          manager.grid[attackerRow][attackerCol] = null;
        }
      }

      function cooperateWithEnemy(manager, row, col, targetRow, targetCol) {
        const cell = manager.grid[row][col];
        const partner = manager.grid[targetRow][targetCol];

        if (!partner) return;
        const share = Math.min(1, cell.energy / 2);

        cell.energy -= share;
        partner.energy = Math.min(GridManager.maxTileEnergy, partner.energy + share);
      }

      function applyEventEffects(cell, row, col, currentEvent) {
        if (
          currentEvent &&
          row >= currentEvent.affectedArea.y &&
          row < currentEvent.affectedArea.y + currentEvent.affectedArea.height &&
          col >= currentEvent.affectedArea.x &&
          col < currentEvent.affectedArea.x + currentEvent.affectedArea.width
        ) {
          const s = currentEvent.strength * uiManager.getEventStrengthMultiplier();

          switch (currentEvent.eventType) {
            case 'flood': {
              const resist = cell.dna.floodResist();

              cell.energy -= 0.3 * s * (1 - resist);
              break;
            }
            case 'drought': {
              const resist = cell.dna.droughtResist();

              cell.energy -= 0.25 * s * (1 - resist);
              break;
            }
            case 'heatwave': {
              const resist = cell.dna.heatResist();

              cell.energy -= 0.35 * s * (1 - resist);
              break;
            }
            case 'coldwave': {
              const resist = cell.dna.coldResist();

              cell.energy -= 0.2 * s * (1 - resist);
              break;
            }
          }
          cell.energy = Math.max(0, Math.min(GridManager.maxTileEnergy, cell.energy));
        }
      }

      function update() {
        if (uiManager.isPaused()) {
          return;
        }

        const now = performance.now();
        const interval = 1000 / Math.max(1, uiManager.getUpdatesPerSecond());

        if (now - lastUpdateTime >= interval) {
          lastUpdateTime = now;
          grid.update();
        }
        grid.draw();
        requestAnimationFrame(update);
      }

      // Create grid and UI
      const grid = new GridManager(rows, cols);
      const uiManager = new UIManager(update, '#app');

      requestAnimationFrame(update);
    </script>
  </body>
</html>
