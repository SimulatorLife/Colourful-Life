<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Colourful Life Simulation</title>
    <link rel="stylesheet" href="styles.css" />
  </head>

  <body>
    <div id="app" class="app-layout">
      <canvas id="gameCanvas" style="width: 600px; height: 600px" width="600" height="600"></canvas>
    </div>
    <script type="module">
      import UIManager from './src/uiManager.js';
      import EventManager from './src/eventManager.js';
      import Stats from './src/stats.js';
      import GridManager from './src/gridManager.js';
      import { drawOverlays } from './src/overlays.js';
      import { computeLeaderboard } from './src/leaderboard.js';

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      const cellSize = 4;
      const rows = canvas.height / cellSize;
      const cols = canvas.width / cellSize;
      let lastUpdateTime = 0;

      const eventManager = new EventManager(rows, cols);
      const stats = new Stats();

      const grid = new GridManager(rows, cols, { eventManager, ctx, cellSize, stats });
      let lastSnapshot = grid.getLastSnapshot();
      let lastLeaderboardRenderTime = 0;
      const uiManager = new UIManager(update, '#app', {
        burst: () => grid.burstRandomCells({ count: 200, radius: 6 }),
      });

      requestAnimationFrame(update);

      function update() {
        if (uiManager.isPaused()) {
          return;
        }

        const now = performance.now();
        const interval = 1000 / Math.max(1, uiManager.getUpdatesPerSecond());
        let tickOccurred = false;

        if (now - lastUpdateTime >= interval) {
          lastUpdateTime = now;
          tickOccurred = true;
          stats.resetTick();
          // update events with frequency and allow up to 2 concurrent
          eventManager.updateEvent(uiManager.getEventFrequencyMultiplier(), 2);
          const snapshot = grid.update({
            densityEffectMultiplier: uiManager.getDensityEffectMultiplier(),
            societySimilarity: uiManager.getSocietySimilarity(),
            enemySimilarity: uiManager.getEnemySimilarity(),
            eventStrengthMultiplier: uiManager.getEventStrengthMultiplier(),
            energyRegenRate: uiManager.getEnergyRegenRate(),
            energyDiffusionRate: uiManager.getEnergyDiffusionRate(),
          });

          lastSnapshot = snapshot;
          // record current event strength for insight charts
          stats.logEvent(eventManager.currentEvent, uiManager.getEventStrengthMultiplier());
          const metrics = stats.updateFromSnapshot(snapshot);

          uiManager.renderMetrics(stats, metrics);
        }
        grid.draw();
        // overlays
        drawOverlays(grid, ctx, cellSize, {
          showEnergy: uiManager.getShowEnergy(),
          showDensity: uiManager.getShowDensity(),
          showFitness: uiManager.getShowFitness(),
          maxTileEnergy: GridManager.maxTileEnergy,
          snapshot: lastSnapshot,
        });
        // leaderboard (top 5 by composite fitness)
        const leaderboardInterval = Math.max(0, uiManager.getLeaderboardIntervalMs());

        if (tickOccurred || now - lastLeaderboardRenderTime >= leaderboardInterval) {
          const top = computeLeaderboard(lastSnapshot, 5);

          uiManager.renderLeaderboard(top);
          lastLeaderboardRenderTime = now;
        }
        requestAnimationFrame(update);
      }

      // overlays and leaderboard moved to modules
    </script>
  </body>
</html>
