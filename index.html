<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Colourful Life Simulation</title>
  <style>
  canvas { display: block; margin: 0 auto; background-color: #000; }
  </style>
</head>
<body>
  <button id="pauseButton">Pause</button>
  <canvas id="gameCanvas"></canvas>
  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 1000;
  canvas.height = 1000;
  const cellSize = 10;
  const rows = canvas.height / cellSize;
  const cols = canvas.width / cellSize;
  const pauseButton = document.getElementById('pauseButton');
  let paused = false;

  function togglePause() {
    paused = !paused;
    pauseButton.textContent = paused ? 'Resume' : 'Pause';
    if (!paused) {
      requestAnimationFrame(update);
    }
  }

  pauseButton.addEventListener('click', togglePause);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'p' || e.key === 'P') {
      togglePause();
    }
  });
  const cellColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
  const reservedColors = {
    flood: 'rgba(0, 0, 255, 0.5)',
    drought: 'rgba(210, 180, 140, 0.5)',
    heatwave: 'rgba(255, 140, 0, 0.5)',
    coldwave: 'rgba(135, 206, 235, 0.5)',
  };

  const chanceToMutate = 0.1;
  const geneMutationRange = 0.2;
  let eventCounter = 0;
  let currentEvent = generateRandomEvent(); // Initialize with an event

  class Cell {
    static maxAge = 10;  // TODO: Implement age-related behavior

    constructor(row, col, color, sight, initPreferences, initGenes, neurons, energy = randomRange(0.5, 2)) {
      this.row = row;
      this.col = col;
      this.color = color || Cell.genesToColor(this.genes);
      this.age = 0;
      this.sight = Math.max(0, sight);
      this.preferences = initPreferences;
      this.energy = energy;
      this.genes = initGenes || Cell.randomGenes();
      this.neurons = neurons;
    }

    static breed(parentA, parentB) {
      const row = parentA.row;
      const col = parentA.col;

      // Randomly inherit one parent's color, with a chance to mutate to a different color
      let newColor = Math.random() < 0.5 ? parentA.color : parentB.color;
      if (Math.random() < chanceToMutate) {
        const availableColors = cellColors.filter(color => color !== newColor);
        newColor = availableColors[Math.floor(Math.random() * availableColors.length)];
      }

      const offspringPreferences = Cell.inheritPreferences(parentA, parentB);
      const newGenes = Cell.inheritGenes(parentA, parentB);
      const neurons = Math.max(1, Math.round((parentA.neurons + parentB.neurons) / 2));
      const offspringEnergy = Math.max((parentA.energy + parentB.energy) / 2, 0.5);
      const offspring = new Cell(row, col, newColor, parentA.sight, offspringPreferences, newGenes, neurons, offspringEnergy);
      parentA.energy /= 2;
      parentB.energy /= 2;

      return offspring;
    }

    static inheritPreferences(parentA, parentB) {
      const preferences = parentA.preferences.map((prefA, index) => {
        const prefB = parentB.preferences[index];
        return (prefA + prefB) / 2 + (Math.random() * geneMutationRange - geneMutationRange / 2); // Inherit preferences with a slight mutation
      });

      return preferences;
    }

    static inheritGenes(parentA, parentB) {
      const newGenes = parentA.genes.map((geneA, index) => {
        const geneB = parentB.genes[index];
        return (geneA + geneB) / 2 + (Math.random() * geneMutationRange - geneMutationRange / 2);
      });
      return newGenes;
    }
  
    static randomGenes() {
        const genes = [];
        for (let a = 0; a < 6; a++) {
          const weights = [];
          for (let i = 0; i < 5; i++) {
            weights.push(Math.random() * 2 - 1);
          }
          genes.push(weights);
        }
        return genes;
      }

    static genesToColor(genes) {
      // Map the first three action weight sums to RGB
      const sums = genes.slice(0, 3).map(arr => arr.reduce((s, w) => s + w, 0));
      const norm = (v) => Math.max(0, Math.min(255, Math.floor((v + 5) / 10 * 255)));
      const r = norm(sums[0]);
      const g = norm(sums[1]);
      const b = norm(sums[2]);
      return `rgb(${r},${g},${b})`;
    }

    findBestMate(potentialMates) {
      let bestMate = null;
      let highestPreference = -Infinity;

      potentialMates.forEach(mate => {
        const preference = this.preferences[cellColors.indexOf(mate.target.color)];
        if (preference > highestPreference) {
          highestPreference = preference;
          bestMate = mate;
        }
      });

      return bestMate;
    }

    decide(n, e, s, w) {
      const inputs = [1, n, e, s, w];
      const scores = this.genes.map(weights =>
        weights.reduce((sum, weight, idx) => sum + weight * inputs[idx], 0)
      );
      let max = scores[0];
      let index = 0;
      for (let i = 1; i < scores.length; i++) {
        if (scores[i] > max) { max = scores[i]; index = i; }
      }
      return index; // 0..5
    }

    decideMove() {
      const [up, down, left, right] = this.genes;
      const total = up + down + left + right;
      const r = Math.random() * total;
      if (r < up) return { dr: -1, dc: 0 };
      if (r < up + down) return { dr: 1, dc: 0 };
      if (r < up + down + left) return { dr: 0, dc: -1 };
      return { dr: 0, dc: 1 };
    }

    // TODO: Implement cloning with mutation – can some cells reproduce asexually?
    cloneWithMutation() {
      const mutated = this.genes.map(row =>
        row.map(w => w + (Math.random() * 0.2 - 0.1))
      );
      return new Cell(this.row, this.col, mutated);
    }

    manageEnergy(isHighDensity) {
      this.energy -= isHighDensity ? 0.8 : 0.055;  // TODO: Make this dynamic/based on genes and based on the actual population, and consider LOCAL population density (based on neighbors/proximity)
      return this.energy <= this.starvationThreshold();
    }

    starvationThreshold() {
      const gene = this.genes[5][0];
      const normalized = (gene + 1) / 2;
      return normalized * GridManager.maxTileEnergy;
    }
  }

  function randomRange(min, max) {
    return Math.random() * (max - min) + min;
  }

  function randomPercent(chance) {
    return Math.random() < chance;
  }

  function generateRandomEvent() {
    const eventTypes = ['flood', 'drought', 'heatwave', 'coldwave'];
    const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
    const duration = Math.floor(Math.random() * 501) + 100; // Event duration between 100 and 600 frames
    const strength = Math.random(); // Event strength between 0 and 1
    const affectedArea = {
      x: Math.floor(Math.random() * cols),
      y: Math.floor(Math.random() * rows),
      width: Math.floor(Math.random() * (cols / 4)) + 1,
      height: Math.floor(Math.random() * (rows / 4)) + 1,
    };
    return { eventType, duration, affectedArea, strength };
  }

  class GridManager {

    static maxTileEnergy = 10;
    static energyRegenRate = 0.2;

    constructor(rows, cols) {
      this.rows = rows;
      this.cols = cols;
      this.grid = new Array(rows).fill(null).map(() => new Array(cols).fill(null));
      this.energyGrid = Array.from({ length: rows }, () => Array.from({ length: cols }, () => GridManager.maxTileEnergy / 2));  // TODO: Make each cell start with a random amount of energy, and largely zero
      this.init();
    }

    init() {
      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          if (Math.random() < 0.05) {
            const genes = Cell.randomGenes(); // properly structured genes
            const preferences = cellColors.map(() => Math.random());
            const neurons = Math.floor(Math.random() * 5) + 1;
            this.grid[row][col] = new Cell(row, col, cellColors[Math.floor(Math.random() * cellColors.length)], Math.floor(Math.random() * 5) + 1, preferences, genes, neurons);
          }
        }
      }
    }

    consumeEnergy(cell, row, col) {
      const available = this.energyGrid[row][col];
      const take = Math.min(1, available);
      this.energyGrid[row][col] -= take;
      cell.energy = Math.min(GridManager.maxTileEnergy, cell.energy + take);
    }

    regenerateEnergyGrid() {
      for (let r = 0; r < this.rows; r++) {
        for (let c = 0; c < this.cols; c++) {
          this.energyGrid[r][c] = Math.min(GridManager.maxTileEnergy, this.energyGrid[r][c] + GridManager.energyRegenRate);
        }
      }
  }

    getCell(row, col) {
      return this.grid[row][col];
    }

    setCell(row, col, cell) {
      this.grid[row][col] = cell;
    }

    draw() {
      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          const cell = this.getCell(row, col);
          if (cell) {
            ctx.fillStyle = cell.color;
            ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
          } else {
            ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);
          }
        }
      }

      // Draw the event area
      if (currentEvent) {
        ctx.fillStyle = reservedColors[currentEvent.eventType];
        ctx.fillRect(
          currentEvent.affectedArea.x * cellSize,
          currentEvent.affectedArea.y * cellSize,
          currentEvent.affectedArea.width * cellSize,
          currentEvent.affectedArea.height * cellSize,
        );
      }
    }
  
    update() {
      const populationDensity = this.calculatePopulationDensity();

      // TODO: Population density should be more localized to each cell's neighborhood (maybe split overall density into a grid of 9 local densities plus immediate neighbors)
      const highDensity = populationDensity > 0.5 + Math.random() * 0.2; // Adjust the threshold for high density as needed
      this.regenerateEnergyGrid();

      // Start a new event when the current one ends
      if (!currentEvent || eventCounter % currentEvent.duration === 0) {
        currentEvent = generateRandomEvent();
        eventCounter = 0; // Reset counter for new event
      }
      eventCounter++;

      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          const cell = this.grid[row][col];

          if (cell) {
            applyEventEffects(cell, row, col, currentEvent);
          
            // Let the cell consume energy from the environment before losing energy
            this.consumeEnergy(cell, row, col);
          
            if (cell.manageEnergy(highDensity)) {
              this.grid[row][col] = null; // Remove the cell if it starved to death
              continue;
            }

            // TODO: Make starvation threshold dynamic based on genes
            // TODO: Move starvation calculation-function into Cell class
            const starving = cell.energy > 0.5 + Math.random();

            // TODO: Current logic relies on sight being a whole-number, so this commented-out part breaks things
            // if (starving) {  // TODO: Make sight-energy influence be dynamic based on genes
            //   cell.sight = Math.max(1, cell.sight - cell.energy); // Decrease sight if starving
            // }

            const { mates, enemies, society } = this.findTargets(row, col, cell, highDensity);

            if (mates.length > 0) {
              const bestMate = cell.findBestMate(mates);
              if (bestMate) {
                moveToTarget(this.grid, row, col, bestMate.row, bestMate.col);  // TODO: Ensure two cells can never occupy the same space; they should move next to each other

                if (randomPercent(0.6) && cell.energy >= 0.5 && bestMate.target.energy >= 0.5) {  // TODO: Make reproduction chance dynamic based on genes
                  const offspring = Cell.breed(cell, bestMate.target);
                  this.grid[row][col] = offspring;  // TODO: Implement proper placement for offspring – ensure it doesn't overlap with existing cells
                }
              }
            } else if (enemies.length > 0) {
              // TODO: Make avoidance behavior dynamic based on genes – some cells should want to avoid, fight, etc.
              const enemyToAvoid = enemies[Math.floor(Math.random() * enemies.length)];
              moveAwayFromTarget(this.grid, row, col, enemyToAvoid.row, enemyToAvoid.col);
            } else {
              moveRandomly(this.grid, row, col, cell);  // TODO: Cells should have different movement behaviors based on genes
            }
          }
        }
      }
    }

    calculatePopulationDensity() {
      let population = 0;
      for (let row = 0; row < this.rows; row++) {
        for (let col = 0; col < this.cols; col++) {
          if (this.grid[row][col]) {
            population++;
          }
        }
      }
      return population / (this.rows * this.cols);
    }

    findTargets(row, col, cell, isHighDensity = false) {    // TODO: Pass population density instead of flag here and make targeting conditions more flexible based on density
      const mates = [];
      const enemies = [];
      const society = [];

      for (let x = -cell.sight; x <= cell.sight; x++) {
        for (let y = -cell.sight; y <= cell.sight; y++) {
          if (x === 0 && y === 0) continue;
          const newRow = (row + y + this.rows) % this.rows;
          const newCol = (col + x + this.cols) % this.cols;
          const target = this.grid[newRow][newCol];
          if (target) {
            if (target.color === cell.color) {
              society.push({ row: newRow, col: newCol, target });
            } else {
              const targetPreference = cell.preferences[cellColors.indexOf(target.color)];
              if (isHighDensity || targetPreference <= 0.5) {
                enemies.push({ row: newRow, col: newCol, target });
              } else {
                mates.push({ row: newRow, col: newCol, target });
              }
            }
          }
        }
      }

      return { mates, enemies, society };
    }

  }

  // TODO: Implement seeding behavior – seed should correspond to gene sequence: 2 cells with the same seed should act exactly the same (in a vacuum)
  function seed(count) {
    for (let i = 0; i < count; i++) {
      const spot = randomEmptyCell();
      if (spot) {
        grid.setCell(spot.r, spot.c, new Cell(spot.r, spot.c));
      }
    }
  }

  function countNeighbors(row, col) {
    const neighbors = {};

    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        if (x === 0 && y === 0) continue;
        const newRow = (row + y + rows) % rows;
        const newCol = (col + x + cols) % cols;
        const cell = grid.getCell(newRow, newCol);
        const color = cell?.color;
        if (color) {
          neighbors[color] = (neighbors[color] || 0) + 1;
        }
      }
    }

    return neighbors;

  }

  /**
   * Move a cell in the grid from (sr, sc) to (dr, dc)
   */
  function tryMove(gridArr, sr, sc, dr, dc) {
    const nr = (sr + dr + rows) % rows;
    const nc = (sc + dc + cols) % cols;
    const dcell = gridArr[nr][nc];
    if (!dcell) {  // Check if the destination cell is empty
      gridArr[nr][nc] = gridArr[sr][sc];
      gridArr[sr][sc] = null;
      return true;
    }
    return false;
  }

  function moveToTarget(gridArr, row, col, targetRow, targetCol) {
    return tryMove(gridArr, row, col, Math.sign(targetRow - row), Math.sign(targetCol - col));
  }

  function moveAwayFromTarget(gridArr, row, col, targetRow, targetCol) {
    return tryMove(gridArr, row, col, -Math.sign(targetRow - row), -Math.sign(targetCol - col));
  }

  function moveRandomly(gridArr, row, col, cell) {
    const { dr, dc } = cell.decideMove();
    return tryMove(gridArr, row, col, dr, dc);
  }

  function applyEventEffects(cell, row, col, currentEvent) {
    if (
      currentEvent &&
      row >= currentEvent.affectedArea.y &&
      row < currentEvent.affectedArea.y + currentEvent.affectedArea.height &&
      col >= currentEvent.affectedArea.x &&
      col < currentEvent.affectedArea.x + currentEvent.affectedArea.width
    ) {
      switch (currentEvent.eventType) {
        case 'flood':
        // Apply flood effects, e.g., remove certain organisms or reduce their energy
        break;
        case 'drought':
        // Apply drought effects, e.g., reduce available energy
        break;
        case 'heatwave':
        // Apply heatwave effects, e.g., remove certain organisms or drain their energy
        break;
        case 'coldwave':
        // Apply coldwave effects, e.g., reduce energy or movement speed
        break;
      }
    }
  }

  function update() {
    if (paused) {
      return;
    }

    grid.update();
    grid.draw();
    requestAnimationFrame(update);
  }

  // Create grid using class
  const grid = new GridManager(rows, cols);
  requestAnimationFrame(update);
  </script>

  </body>
  </html>
