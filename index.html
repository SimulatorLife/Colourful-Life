<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Colourful Life Simulation</title>
  <style>
  canvas { display: block; margin: 0 auto; background-color: #000; }
  </style>
</head>
<body>
  <button id="pauseButton">Pause</button>
  <canvas id="gameCanvas"></canvas>
  <script>
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 1000;
  canvas.height = 1000;
  const cellSize = 10;
  const rows = canvas.height / cellSize;
  const cols = canvas.width / cellSize;
  const pauseButton = document.getElementById('pauseButton');
  let paused = false;

  function togglePause() {
    paused = !paused;
    pauseButton.textContent = paused ? 'Resume' : 'Pause';
    if (!paused) {
      requestAnimationFrame(update);
    }
  }

  pauseButton.addEventListener('click', togglePause);
  document.addEventListener('keydown', (e) => {
    if (e.key === 'p' || e.key === 'P') {
      togglePause();
    }
  });
  const cellColors = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF'];
  const reservedColors = {
    flood: 'rgba(0, 0, 255, 0.5)',
    drought: 'rgba(210, 180, 140, 0.5)',
    heatwave: 'rgba(255, 140, 0, 0.5)',
    coldwave: 'rgba(135, 206, 235, 0.5)',
  };

  const chanceToMutate = 0.1;
  const geneMutationRange = 0.2;
  let eventCounter = 0;
  let currentEvent = generateRandomEvent(); // Initialize with an event

  const maxTileEnergy = 5;
  const energyRegenRate = 0.05;
  const energyGrid = Array.from({ length: rows }, () => Array.from({ length: cols }, () => maxTileEnergy / 2));

  class Cell {
    static maxAge = 10;  // TODO: Implement age-related behavior

    constructor(row, col, color, sight, initPreferences, initGenes, neurons) {
      this.row = row;
      this.col = col;
      this.color = color || Cell.genesToColor(this.genes);
      this.age = 0;
      this.sight = sight;
      this.preferences = initPreferences;
      this.energy = maxTileEnergy / 2;
      this.genes = initGenes || Cell.randomGenes();
      this.neurons = neurons;
    }

    static inheritPreferences(parentA, parentB) {
      const preferences = parentA.preferences.map((prefA, index) => {
        const prefB = parentB.preferences[index];
        return (prefA + prefB) / 2 + (Math.random() * geneMutationRange - geneMutationRange / 2); // Inherit preferences with a slight mutation
      });

      return preferences;
    }

    static inheritGenes(parentA, parentB) {
      const newGenes = parentA.genes.map((geneA, index) => {
        const geneB = parentB.genes[index];
        return (geneA + geneB) / 2 + (Math.random() * geneMutationRange - geneMutationRange / 2);
      });
      return newGenes;
    }
  
    static randomGenes() {
        const genes = [];
        for (let a = 0; a < 6; a++) {
          const weights = [];
          for (let i = 0; i < 5; i++) {
            weights.push(Math.random() * 2 - 1);
          }
          genes.push(weights);
        }
        return genes;
      }

    static genesToColor(genes) {
      // Map the first three action weight sums to RGB
      const sums = genes.slice(0, 3).map(arr => arr.reduce((s, w) => s + w, 0));
      const norm = (v) => Math.max(0, Math.min(255, Math.floor((v + 5) / 10 * 255)));
      const r = norm(sums[0]);
      const g = norm(sums[1]);
      const b = norm(sums[2]);
      return `rgb(${r},${g},${b})`;
    }

    findBestMate(potentialMates) {
      let bestMate = null;
      let highestPreference = -Infinity;

      potentialMates.forEach(mate => {
        const preference = this.preferences[cellColors.indexOf(mate.target.color)];
        if (preference > highestPreference) {
          highestPreference = preference;
          bestMate = mate;
        }
      });

      return bestMate;
    }

    decide(n, e, s, w) {
      const inputs = [1, n, e, s, w];
      const scores = this.genes.map(weights =>
        weights.reduce((sum, weight, idx) => sum + weight * inputs[idx], 0)
      );
      let max = scores[0];
      let index = 0;
      for (let i = 1; i < scores.length; i++) {
        if (scores[i] > max) { max = scores[i]; index = i; }
      }
      return index; // 0..5
    }

    decideMove() {
      const [up, down, left, right] = this.genes;
      const total = up + down + left + right;
      const r = Math.random() * total;
      if (r < up) return { dr: -1, dc: 0 };
      if (r < up + down) return { dr: 1, dc: 0 };
      if (r < up + down + left) return { dr: 0, dc: -1 };
      return { dr: 0, dc: 1 };
    }

    // TODO: Implement cloning with mutation â€“ can some cells reproduce asexually?
    cloneWithMutation() {
      const mutated = this.genes.map(row =>
        row.map(w => w + (Math.random() * 0.2 - 0.1))
      );
      return new Cell(this.row, this.col, mutated);
    }

    manageEnergy(row, col) {
      // Determine local population density
      const neighborCounts = countNeighbors(row, col);
      const neighbors = Object.values(neighborCounts).reduce((sum, n) => sum + n, 0);

      // Use the last gene row as a simple metabolism indicator. Higher absolute
      // values increase the amount of energy consumed each tick.
      const metabolism = this.genes[5]?.reduce((s, g) => s + Math.abs(g), 0) /
        (this.genes[5]?.length || 1);

      // Base energy loss is scaled by both metabolism and local density.
      const energyLoss = 0.05 * (1 + metabolism) * (1 + neighbors);
      this.energy -= energyLoss;

      return this.energy <= 0;  // TODO: Cells should have different starvation levels based on genes
    }
  }

  function generateRandomEvent() {
    const eventTypes = ['flood', 'drought', 'heatwave', 'coldwave'];
    const eventType = eventTypes[Math.floor(Math.random() * eventTypes.length)];
    const duration = Math.floor(Math.random() * 501) + 100; // Event duration between 100 and 600 frames
    const strength = Math.random(); // Event strength between 0 and 1
    const affectedArea = {
      x: Math.floor(Math.random() * cols),
      y: Math.floor(Math.random() * rows),
      width: Math.floor(Math.random() * (cols / 4)) + 1,
      height: Math.floor(Math.random() * (rows / 4)) + 1,
    };
    return { eventType, duration, affectedArea, strength };
  }

  function consumeEnergy(cell, row, col) {
    const available = energyGrid[row][col];
    const take = Math.min(1, available);
    energyGrid[row][col] -= take;
    cell.energy = Math.min(maxTileEnergy, cell.energy + take);
  }

  function regenerateEnergyGrid() {
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        energyGrid[r][c] = Math.min(maxTileEnergy, energyGrid[r][c] + energyRegenRate);
      }
    }
  }

  const grid = new Array(rows).fill(null).map(() => new Array(cols).fill(null));

  function initGrid() {
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (Math.random() < 0.05) {
          const genes = Array.from({ length: 4 }, () => Math.random()); // movement weights
          const preferences = cellColors.map(() => Math.random());
          const neurons = Math.floor(Math.random() * 5) + 1;
          grid[row][col] = new Cell(row, col, cellColors[Math.floor(Math.random() * cellColors.length)], Math.floor(Math.random() * 5) + 1, preferences, genes, neurons);
        }
      }
    }
  }

  function drawGrid() {
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (grid[row][col]) {
          ctx.fillStyle = grid[row][col].color;
          ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
        } else {
          ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);
        }
      }
    }

    // Draw the event area
    if (currentEvent) {
      ctx.fillStyle = reservedColors[currentEvent.eventType];
      ctx.fillRect(
        currentEvent.affectedArea.x * cellSize,
        currentEvent.affectedArea.y * cellSize,
        currentEvent.affectedArea.width * cellSize,
        currentEvent.affectedArea.height * cellSize,
      );
    }
  }

  // TODO: Implement seeding behavior
  function seed(count) {
    for (let i = 0; i < count; i++) {
      const spot = randomEmptyCell();
      if (spot) {
        grid[spot.r][spot.c] = new Cell(spot.r, spot.c);
      }
    }
  }

  function countNeighbors(row, col) {
    const neighbors = {};

    for (let x = -1; x <= 1; x++) {
      for (let y = -1; y <= 1; y++) {
        if (x === 0 && y === 0) continue;
        const newRow = (row + y + rows) % rows;
        const newCol = (col + x + cols) % cols;
        const color = grid[newRow][newCol]?.color;
        if (color) {
          neighbors[color] = (neighbors[color] || 0) + 1;
        }
      }
    }

    return neighbors;

  }

  function findTargets(row, col, cell, highDensity) {
    const mates = [];
    const enemies = [];
    const society = [];

    for (let x = -cell.sight; x <= cell.sight; x++) {
      for (let y = -cell.sight; y <= cell.sight; y++) {
        if (x === 0 && y === 0) continue;
        const newRow = (row + y + rows) % rows;
        const newCol = (col + x + cols) % cols;
        const target = grid[newRow][newCol];
        if (target) {
          if (target.color === cell.color) {
            society.push({ row: newRow, col: newCol, target });
          } else {
            const targetPreference = cell.preferences[cellColors.indexOf(target.color)];
            if (highDensity || targetPreference <= 0.5) {
              enemies.push({ row: newRow, col: newCol, target });
            } else {
              mates.push({ row: newRow, col: newCol, target });
            }
          }
        }
      }
    }

    return { mates, enemies, society };
  }

  function tryMove(row, col, dr, dc) {
    const nr = (row + dr + rows) % rows;
    const nc = (col + dc + cols) % cols;
    if (!grid[nr][nc]) {
      grid[nr][nc] = grid[row][col];
      grid[row][col] = null;
      consumeEnergy(grid[nr][nc], nr, nc);
    }
  }

  function moveToTarget(row, col, targetRow, targetCol) {
    tryMove(row, col, Math.sign(targetRow - row), Math.sign(targetCol - col));
  }

  function moveAwayFromTarget(row, col, targetRow, targetCol) {
    tryMove(row, col, -Math.sign(targetRow - row), -Math.sign(targetCol - col));
  }

  function moveRandomly(row, col, cell) {
    const { dr, dc } = cell.decideMove();
    tryMove(row, col, dr, dc);
  }

  function calculatePopulationDensity() {
    let population = 0;
    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        if (grid[row][col]) {
          population++;
        }
      }
    }
    return population / (rows * cols);
  }

  function applyEventEffects(cell, row, col, currentEvent) {
    if (
      currentEvent &&
      row >= currentEvent.affectedArea.y &&
      row < currentEvent.affectedArea.y + currentEvent.affectedArea.height &&
      col >= currentEvent.affectedArea.x &&
      col < currentEvent.affectedArea.x + currentEvent.affectedArea.width
    ) {
      switch (currentEvent.eventType) {
        case 'flood':
        // Apply flood effects, e.g., remove certain organisms or reduce their energy
        break;
        case 'drought':
        // Apply drought effects, e.g., reduce available energy
        break;
        case 'heatwave':
        // Apply heatwave effects, e.g., remove certain organisms or drain their energy
        break;
        case 'coldwave':
        // Apply coldwave effects, e.g., reduce energy or movement speed
        break;
      }
    }
  }

  function breed(parentA, parentB) {
    const row = parentA.row;
    const col = parentA.col;

    // Randomly inherit one parent's color, with a chance to mutate to a different color
    let newColor = Math.random() < 0.5 ? parentA.color : parentB.color;
    if (Math.random() < chanceToMutate) {
      const availableColors = cellColors.filter(color => color !== newColor);
      newColor = availableColors[Math.floor(Math.random() * availableColors.length)];
    }

    const offspringPreferences = Cell.inheritPreferences(parentA, parentB);
    const newGenes = Cell.inheritGenes(parentA, parentB);
    const neurons = Math.max(1, Math.round((parentA.neurons + parentB.neurons) / 2));
    const offspring = new Cell(row, col, newColor, parentA.sight, offspringPreferences, newGenes, neurons);
    offspring.energy = (parentA.energy + parentB.energy) / 4;
    parentA.energy /= 2;
    parentB.energy /= 2;

    return offspring;
  }

  function updateGrid() {
    const populationDensity = calculatePopulationDensity();

    // TODO: Population density should be more localized to each cell's neighborhood (maybe split overall density into a grid of 9 local densities plus immediate neighbors)
    const highDensity = populationDensity > 0.1 + Math.random() * 0.2; // Adjust the threshold for high density as needed
    regenerateEnergyGrid();

    // TODO: Are these two separate if statements needed?
    if (eventCounter % 2000 === 0) {
      currentEvent = generateRandomEvent();
    }
    if (currentEvent && eventCounter % (2000 + currentEvent.duration) === 0) {
      currentEvent = generateRandomEvent();
    }
    eventCounter++;

    for (let row = 0; row < rows; row++) {
      for (let col = 0; col < cols; col++) {
        const cell = grid[row][col];

        if (cell) {
          applyEventEffects(cell, row, col, currentEvent);

            if (cell.manageEnergy(row, col)) {
            grid[row][col] = null; // Remove the cell if it starved to death
            continue;
          }

          // TODO: Make starvation threshold dynamic based on genes
          // TODO: Move starvation calculation-function into Cell class
          const starving = cell.hunger > Math.max(0.5 + Math.random(), 1);

          if (starving) {  // TODO: Make sight-hunger influence be dynamic based on genes
            cell.sight = Math.max(1, cell.sight - cell.hunger); // Decrease sight if starving
          }

          const { mates, enemies, society } = findTargets(row, col, cell, highDensity);

          if (mates.length > 0) {
            const bestMate = cell.findBestMate(mates);
            if (bestMate) {
              moveToTarget(row, col, bestMate.row, bestMate.col);  // TODO: Ensure two cells can never occupy the same space; they should move next to each other

              if (Math.random() < 0.1 && cell.energy > 2 && bestMate.target.energy > 2) {  // TODO: Make reproduction chance dynamic based on genes
                const offspring = breed(cell, bestMate.target);
                grid[row][col] = offspring;
              }
            }
          } else if (enemies.length > 0) {
            // TODO: Make avoidance behavior dynamic based on genes â€“ some cells should want to avoid, fight, etc.
            const enemyToAvoid = enemies[Math.floor(Math.random() * enemies.length)];
            moveAwayFromTarget(row, col, enemyToAvoid.row, enemyToAvoid.col);
          } else {
            moveRandomly(row, col, cell);  // TODO: Cells should have different movement behaviors based on genes
          }
        }
      }
    }
  }

  function update() {
    if (paused) {
      return;
    }
    updateGrid();
    drawGrid();
    requestAnimationFrame(update);
  }

  initGrid();
  drawGrid();
  if (!paused) {
    requestAnimationFrame(update);
  }
  </script>

  </body>
  </html>
