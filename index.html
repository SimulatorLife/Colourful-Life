<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Colourful Life Simulation</title>
    <style>
      canvas {
        display: block;
        margin: 0 auto;
        background-color: #000;
      }

      body {
        background-color: #222;
      }
    </style>
  </head>

  <body>
    <button id="pauseButton">Pause</button>
    <div
      id="controls"
      style="
        color: #ddd;
        font-family: sans-serif;
        max-width: 1000px;
        margin: 8px auto;
        display: flex;
        gap: 16px;
        align-items: center;
        flex-wrap: wrap;
      "
    >
      <label
        >Society ≥ <span id="socVal">0.85</span>
        <input id="socSlider" type="range" min="0" max="1" step="0.01" value="0.85" />
      </label>
      <label
        >Enemy ≤ <span id="eneVal">0.50</span>
        <input id="eneSlider" type="range" min="0" max="1" step="0.01" value="0.50" />
      </label>
      <label
        >Event Strength × <span id="evtVal">1.0</span>
        <input id="evtSlider" type="range" min="0" max="3" step="0.05" value="1.0" />
      </label>
    </div>
    <canvas id="gameCanvas"></canvas>
    <script type="module">
      import { randomRange, randomPercent, createRNG } from './utils.js';
      import UIManager from './uiManager.js';
      import EventManager from './eventManager.js';

      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');

      canvas.width = 800;
      canvas.height = 800;
      const cellSize = 8;
      const rows = canvas.height / cellSize;
      const cols = canvas.width / cellSize;
      // Simulation speed control
      let updatesPerSecond = 50; // updates per second
      let lastUpdateTime = 0;

      const eventManager = new EventManager(rows, cols);

      // Colors are derived from genes; no fixed palette
      const reservedColors = {
        flood: 'rgba(0, 0, 255, 0.5)',
        drought: 'rgba(210, 180, 140, 0.5)',
        heatwave: 'rgba(255, 140, 0, 0.5)',
        coldwave: 'rgba(135, 206, 235, 0.5)',
      };
      // Tunables (wired to UI)
      let SOCIETY_SIMILARITY = 0.85;
      let ENEMY_SIMILARITY = 0.5;
      let EVENT_STRENGTH_MULTIPLIER = 1.0;
      const socSlider = document.getElementById('socSlider');
      const eneSlider = document.getElementById('eneSlider');
      const evtSlider = document.getElementById('evtSlider');
      const socVal = document.getElementById('socVal');
      const eneVal = document.getElementById('eneVal');
      const evtVal = document.getElementById('evtVal');

      socSlider.addEventListener('input', () => {
        SOCIETY_SIMILARITY = parseFloat(socSlider.value);
        socVal.textContent = SOCIETY_SIMILARITY.toFixed(2);
      });
      eneSlider.addEventListener('input', () => {
        ENEMY_SIMILARITY = parseFloat(eneSlider.value);
        eneVal.textContent = ENEMY_SIMILARITY.toFixed(2);
      });
      evtSlider.addEventListener('input', () => {
        EVENT_STRENGTH_MULTIPLIER = parseFloat(evtSlider.value);
        evtVal.textContent = EVENT_STRENGTH_MULTIPLIER.toFixed(2);
      });
      // Attach speed slider dynamically to the controls bar
      (function attachSpeedControl() {
        const controls = document.getElementById('controls');

        if (!controls) return;
        const label = document.createElement('label');

        label.innerHTML = 'Speed <span id="spdVal"></span> ups';
        const input = document.createElement('input');

        input.id = 'spdSlider';
        input.type = 'range';
        input.min = '1';
        input.max = '60';
        input.step = '1';
        input.value = String(updatesPerSecond);
        label.appendChild(input);
        controls.appendChild(label);
        const spdVal = label.querySelector('#spdVal');

        spdVal.textContent = String(updatesPerSecond);
        input.addEventListener('input', () => {
          updatesPerSecond = parseInt(input.value, 10) || 1;
          spdVal.textContent = String(updatesPerSecond);
        });
      })();

      class DNA {
        constructor(r, g, b) {
          this.r = r | 0;
          this.g = g | 0;
          this.b = b | 0;
        }

        static random(rng = Math.random) {
          return new DNA(Math.floor(rng() * 256), Math.floor(rng() * 256), Math.floor(rng() * 256));
        }

        toColor() {
          return `rgb(${this.r},${this.g},${this.b})`;
        }

        seed() {
          return (this.r | (this.g << 8) | (this.b << 16)) >>> 0;
        }

        prng() {
          return createRNG(this.seed());
        }

        // Expand RGB genome to a 6x5 weight matrix in [-1,1]
        weights() {
          const rnd = this.prng();
          const rows = [];

          for (let a = 0; a < 6; a++) {
            const row = [];

            for (let i = 0; i < 5; i++) {
              row.push(rnd() * 2 - 1);
            }
            rows.push(row);
          }

          return rows;
        }

        movementGenes() {
          const rnd = this.prng();

          return {
            wandering: rnd(),
            pursuit: rnd(),
            cautious: rnd(),
          };
        }

        interactionGenes() {
          const rnd = this.prng();

          return { avoid: rnd(), fight: rnd(), cooperate: rnd() };
        }

        reproductionProb() {
          const rnd = this.prng();
          // Bias by green channel (resource affinity): 0.2..0.6
          const base = 0.2 + (this.g / 255) * 0.4;

          // small deterministic jitter
          return Math.min(0.8, Math.max(0.05, base * (0.9 + rnd() * 0.2)));
        }

        initialEnergy(maxEnergy = 5) {
          const brightness = (this.r + this.g + this.b) / (3 * 255);

          return Math.max(0.5, Math.min(maxEnergy, 0.5 + brightness * (maxEnergy - 0.5)));
        }

        lifespan(maxAge = 1000) {
          const rnd = this.prng();
          // Map blue to longer life; add small deterministic variation
          const base = 0.5 + (this.b / 255) * 0.5; // 0.5..1.0 of maxAge
          const lifespanAdj = ((this.b - 127.5) / 255) * 100;

          return Math.max(
            Cell.minAge,
            Math.round(maxAge * (base * (0.95 + rnd() * 0.1))) + lifespanAdj
          );
        }

        floodResist() {
          return this.b / 255;
        }

        heatResist() {
          return this.r / 255;
        }

        droughtResist() {
          return this.g / 255;
        }

        coldResist() {
          return (this.g + this.b) / (2 * 255);
        }

        mutationChance() {
          const rnd = this.prng();

          return 0.08 + rnd() * 0.2; // 0.08..0.28
        }

        mutationRange() {
          const rnd = this.prng();

          return 6 + Math.floor(rnd() * 20); // 6..25
        }

        starvationThresholdFrac() {
          // Higher green -> better resource efficiency, lower threshold
          // Map to 0.2..0.8
          return 0.8 - (this.g / 255) * 0.6;
        }

        neurons() {
          const rnd = this.prng();

          return Math.max(1, Math.floor(rnd() * 5) + 1);
        }

        sight() {
          const rnd = this.prng();

          return Math.max(1, Math.floor(rnd() * 5) + 1);
        }

        baseEnergyLossScale() {
          // Higher brightness -> higher metabolism
          const brightness = (this.r + this.g + this.b) / (3 * 255);

          return 0.5 + brightness; // 0.5..1.5 scale
        }

        strategy() {
          const rnd = this.prng();

          return rnd(); // 0..1
        }

        lifespanAdj() {
          // Map blue channel to lifespan adjustment roughly -50..+50
          return ((this.b - 127.5) / 255) * 100;
        }

        reproduceWith(other, mutationChance = 0.15, mutationRange = 12) {
          const mix = (a, b) => {
            let v = Math.round((a + b) / 2);

            if (Math.random() < mutationChance) {
              v += Math.floor((Math.random() * 2 - 1) * mutationRange);
            }

            return Math.max(0, Math.min(255, v));
          };

          return new DNA(mix(this.r, other.r), mix(this.g, other.g), mix(this.b, other.b));
        }
        similarity(other) {
          const dx = this.r - other.r,
            dy = this.g - other.g,
            dz = this.b - other.b;
          const dist = Math.sqrt(dx * dx + dy * dy + dz * dz);
          const maxDist = Math.sqrt(3 * 255 * 255);

          return 1 - dist / maxDist;
        }
      }

      class Cell {
        // TODO: The cells' colors should BE their genes. The RGB values should BE the DNA
        // Each value (0-255) represents genes that control behavior
        // Every one of the cell's preferences, inheritable traits, etc. is derived from these genes
        // This will make it easier to visualize evolution and relationships between cells: for any given cell, its color is a direct representation of its genetic code

        static baseEnergyLoss = 0.05;
        static chanceToMutate = 0.15;
        static geneMutationRange = 0.2;
        static minAge = 100;

        constructor(row, col, dna, energy) {
          this.row = row;
          this.col = col;
          this.dna = dna || DNA.random();
          this.genes = this.dna.weights();
          this.color = this.dna.toColor();
          this.age = 0;
          this.lifespan = this.dna.lifespan(Cell.maxAge);
          this.sight = this.dna.sight();
          this.energy = energy ?? this.dna.initialEnergy(GridManager.maxTileEnergy);
          this.neurons = this.dna.neurons();
          this.strategy = this.dna.strategy(); // Gene-controlled strategy for enemy encounters: 0..1: avoid, fight, cooperate
          this.movementGenes = this.dna.movementGenes();
          this.interactionGenes = this.dna.interactionGenes();
        }

        /**
         * Create a new cell by combining traits from two parents.
         * The offspring inherits position, color, genes, and other
         * attributes from its parents with a chance for mutation.
         *
         * @param {Cell} parentA - First parent providing location and traits.
         * @param {Cell} parentB - Second parent contributing traits.
         * @returns {Cell} A new child cell placed at parentA's position.
         */
        static breed(parentA, parentB) {
          const row = parentA.row;
          const col = parentA.col;

          // Inherit and mutate DNA; all traits derive from DNA
          const chance = (parentA.dna.mutationChance() + parentB.dna.mutationChance()) / 2;
          const range = Math.round((parentA.dna.mutationRange() + parentB.dna.mutationRange()) / 2);
          const childDNA = parentA.dna.reproduceWith(parentB.dna, chance, range);
          const offspringEnergy = Math.max((parentA.energy + parentB.energy) / 2, 0.5);
          const offspring = new Cell(row, col, childDNA, offspringEnergy);
          const strategy =
            (parentA.strategy + parentB.strategy) / 2 +
            (Math.random() * Cell.geneMutationRange - Cell.geneMutationRange / 2);

          offspring.strategy = Math.min(1, Math.max(0, strategy));
          parentA.energy /= 2;
          parentB.energy /= 2;

          return offspring;
        }

        similarityTo(other) {
          return this.dna.similarity(other.dna);
        }

        static computeLifespan(genes) {
          const gene = genes?.[0]?.[0] ?? 0;
          const factor = Math.max(0, 1 + gene);

          return Math.round(600 * factor + randomRange(0, 600));
        }

        findBestMate(potentialMates) {
          let bestMate = null;
          let highestPreference = -Infinity;

          potentialMates.forEach((mate) => {
            const preference = this.similarityTo(mate.target);

            if (preference > highestPreference) {
              highestPreference = preference;
              bestMate = mate;
            }
          });

          return bestMate;
        }

        /**
         * Determine which action to take based on input signals from the
         * north, east, south, and west. Each potential action corresponds
         * to a row in `this.genes`, and its score is the dot product of the
         * row's weights with the input vector. The index of the highest
         * score is returned.
         *
         * @param {number} n - Stimulus from the northern neighbor.
         * @param {number} e - Stimulus from the eastern neighbor.
         * @param {number} s - Stimulus from the southern neighbor.
         * @param {number} w - Stimulus from the western neighbor.
         * @returns {number} Index of the selected action (0-5).
         */
        decide(n, e, s, w) {
          // Include a constant bias term plus directional inputs
          const inputs = [1, n, e, s, w];
          // Score each possible action by multiplying weights with inputs
          const scores = this.genes.map((weights) =>
            weights.reduce((sum, weight, idx) => sum + weight * inputs[idx], 0)
          );
          // Identify the index of the highest scoring action
          let max = scores[0];
          let index = 0;

          for (let i = 1; i < scores.length; i++) {
            if (scores[i] > max) {
              max = scores[i];
              index = i;
            }
          }

          return index; // Action index 0..5
        }

        decideMove() {
          // Simple uniform random cardinal move; could be refined via DNA
          const r = Math.floor(Math.random() * 4);

          if (r === 0) return { dr: -1, dc: 0 };
          if (r === 1) return { dr: 1, dc: 0 };
          if (r === 2) return { dr: 0, dc: -1 };

          return { dr: 0, dc: 1 };
        }

        manageEnergy(row, col) {
          // Determine local population density
          const neighborCounts = countNeighbors(row, col);
          const neighborTotal = Object.values(neighborCounts).reduce((sum, n) => sum + n, 0);
          const density = neighborTotal / 8; // Normalize to [0, 1]

          // Use the last gene row as a simple metabolism indicator. Higher absolute
          // values increase the amount of energy consumed each tick.
          const geneRow = this.genes?.[5];
          const metabolism = Array.isArray(geneRow)
            ? geneRow.reduce((s, g) => s + Math.abs(g), 0) / (geneRow.length || 1)
            : Math.abs(Number(geneRow) || 0);

          // Base energy loss is scaled by metabolism, local density, and DNA-driven metabolism scale.
          const energyLoss =
            Cell.baseEnergyLoss * this.dna.baseEnergyLossScale() * (1 + metabolism) * (1 + density);

          this.energy -= energyLoss;

          return this.energy <= this.starvationThreshold();
        }

        starvationThreshold() {
          return this.dna.starvationThresholdFrac() * GridManager.maxTileEnergy;
        }

        static randomMovementGenes() {
          return {
            wandering: Math.random(),
            pursuit: Math.random(),
            cautious: Math.random(),
          };
        }

        chooseMovementStrategy() {
          const { wandering, pursuit, cautious } = this.movementGenes;
          const total = wandering + pursuit + cautious;
          const r = Math.random() * total;

          if (r < wandering) return 'wandering';
          if (r < wandering + pursuit) return 'pursuit';

          return 'cautious';
        }

        executeMovementStrategy(gridArr, row, col, mates, enemies, society) {
          const strategy = this.chooseMovementStrategy();

          if (strategy === 'pursuit' && society.length > 0) {
            const target = society[Math.floor(Math.random() * society.length)];

            moveToTarget(gridArr, row, col, target.row, target.col);
          } else if (strategy === 'cautious' && society.length > 0) {
            const target = society[Math.floor(Math.random() * society.length)];

            moveAwayFromTarget(gridArr, row, col, target.row, target.col);
          } else {
            moveRandomly(gridArr, row, col, this);
          }
        }
      }

      class GridManager {
        // Static properties
        static maxTileEnergy = 5;
        static energyRegenRate = 0.25;

        constructor(rows, cols) {
          this.rows = rows;
          this.cols = cols;
          this.grid = Array.from({ length: rows }, () => Array(cols).fill(null));
          this.energyGrid = Array.from({ length: rows }, () =>
            Array.from({ length: cols }, () => GridManager.maxTileEnergy / 2)
          );
          this.init();
        }

        init() {
          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              if (Math.random() < 0.05) {
                const dna = DNA.random();

                this.grid[row][col] = new Cell(row, col, dna);
              }
            }
          }
        }

        consumeEnergy(cell, row, col) {
          const available = this.energyGrid[row][col];
          const take = Math.min(1, available);

          this.energyGrid[row][col] -= take;
          cell.energy = Math.min(GridManager.maxTileEnergy, cell.energy + take);
        }

        regenerateEnergyGrid() {
          for (let r = 0; r < this.rows; r++) {
            for (let c = 0; c < this.cols; c++) {
              this.energyGrid[r][c] = Math.min(
                GridManager.maxTileEnergy,
                this.energyGrid[r][c] + GridManager.energyRegenRate
              );
            }
          }
        }

        getCell(row, col) {
          return this.grid[row][col];
        }
        setCell(row, col, cell) {
          this.grid[row][col] = cell;
        }

        draw() {
          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              const cell = this.getCell(row, col);

              if (cell) {
                ctx.fillStyle = cell.color;
                ctx.fillRect(col * cellSize, row * cellSize, cellSize, cellSize);
              } else {
                ctx.clearRect(col * cellSize, row * cellSize, cellSize, cellSize);
              }
            }
          }
          if (eventManager.currentEvent) {
            ctx.fillStyle = reservedColors[eventManager.currentEvent.eventType];
            ctx.fillRect(
              eventManager.currentEvent.affectedArea.x * cellSize,
              eventManager.currentEvent.affectedArea.y * cellSize,
              eventManager.currentEvent.affectedArea.width * cellSize,
              eventManager.currentEvent.affectedArea.height * cellSize
            );
          }
        }

        update() {
          // TODO: Break this function up into smaller functions & make it more readable
          const populationDensity = this.calculatePopulationDensity();
          const minPopulation = Math.floor(this.rows * this.cols * 0.05);
          const currentPopulation = Math.floor(populationDensity * this.rows * this.cols);

          seed(currentPopulation, minPopulation);

          const highDensity = populationDensity > 0.5 + Math.random() * 0.2;

          this.regenerateEnergyGrid();
          eventManager.updateEvent();

          const processed = new WeakSet();

          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              const cell = this.grid[row][col];

              if (!cell || processed.has(cell)) continue;
              processed.add(cell);

              cell.age++;
              if (cell.age >= cell.lifespan) {
                this.grid[row][col] = null;
                continue;
              }

              applyEventEffects(cell, row, col, eventManager.currentEvent);
              this.consumeEnergy(cell, row, col);
              cell.manageEnergy(row, col);
              if (cell.energy <= 0) {
                this.grid[row][col] = null;
                continue;
              }

              const { mates, enemies, society } = this.findTargets(row, col, cell, highDensity);

              if (mates.length > 0) {
                const bestMate = cell.findBestMate(mates);

                if (bestMate) {
                  moveToTarget(this.grid, row, col, bestMate.row, bestMate.col);
                  const reproProb =
                    (cell.dna.reproductionProb() + bestMate.target.dna.reproductionProb()) / 2;

                  if (
                    randomPercent(reproProb) &&
                    cell.energy >= 0.5 &&
                    bestMate.target.energy >= 0.5
                  ) {
                    const offspring = Cell.breed(cell, bestMate.target);

                    this.grid[row][col] = offspring;
                  }
                }
              } else if (enemies.length > 0) {
                const targetEnemy = enemies[Math.floor(Math.random() * enemies.length)];
                // Choose interaction by DNA interaction genes
                const { avoid, fight, cooperate } = cell.interactionGenes;
                const total = avoid + fight + cooperate;
                const roll = Math.random() * total;

                if (roll < avoid) {
                  moveAwayFromTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                } else if (roll < avoid + fight) {
                  const dist = Math.max(
                    Math.abs(targetEnemy.row - row),
                    Math.abs(targetEnemy.col - col)
                  );

                  if (dist <= 1) fightEnemy(this, row, col, targetEnemy.row, targetEnemy.col);
                  else moveToTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                } else {
                  const dist = Math.max(
                    Math.abs(targetEnemy.row - row),
                    Math.abs(targetEnemy.col - col)
                  );

                  if (dist <= 1)
                    cooperateWithEnemy(this, row, col, targetEnemy.row, targetEnemy.col);
                  else moveToTarget(this.grid, row, col, targetEnemy.row, targetEnemy.col);
                }
              } else {
                // Use DNA-driven movement strategy when idle
                cell.executeMovementStrategy(this.grid, row, col, mates, enemies, society || []);
              }
            }
          }
        }

        calculatePopulationDensity() {
          let population = 0;

          for (let row = 0; row < this.rows; row++) {
            for (let col = 0; col < this.cols; col++) {
              if (this.grid[row][col]) {
                population++;
              }
            }
          }

          return population / (this.rows * this.cols);
        }

        findTargets(row, col, cell, isHighDensity = false) {
          const mates = [];
          const enemies = [];
          const society = [];

          for (let x = -cell.sight; x <= cell.sight; x++) {
            for (let y = -cell.sight; y <= cell.sight; y++) {
              if (x === 0 && y === 0) continue;
              const newRow = (row + y + this.rows) % this.rows;
              const newCol = (col + x + this.cols) % this.cols;
              const target = this.grid[newRow][newCol];

              if (target) {
                const similarity = cell.similarityTo(target);

                if (similarity >= SOCIETY_SIMILARITY) {
                  society.push({ row: newRow, col: newCol, target });
                } else if (isHighDensity || similarity <= ENEMY_SIMILARITY) {
                  enemies.push({ row: newRow, col: newCol, target });
                } else {
                  mates.push({ row: newRow, col: newCol, target });
                }
              }
            }
          }

          return { mates, enemies, society };
        }
      }

      // TODO: Lots of the following methods should be moved to the Cell, EventManager, or GridManager classes

      // TODO: Improve seeding behavior – seed should correspond to gene sequence: 2 cells with the same seed should act exactly the same (in a vacuum)
      // Seed new cells if the population drops below a minimum threshold
      function seed(current, minPopulation, seedValue) {
        if (current >= minPopulation) return;

        const rng = seedValue !== undefined ? createRNG(seedValue) : Math.random;

        const empty = [];

        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            if (!grid.getCell(r, c)) empty.push({ r, c });
          }
        }

        const toSeed = Math.min(minPopulation - current, empty.length);

        for (let i = 0; i < toSeed; i++) {
          const idx = Math.floor(rng() * empty.length);
          const { r, c } = empty.splice(idx, 1)[0];
          const dna = DNA.random(rng);
          const newCell = new Cell(r, c, dna);

          grid.setCell(r, c, newCell);
        }
      }

      function countNeighbors(row, col) {
        const neighbors = {};

        for (let x = -1; x <= 1; x++) {
          for (let y = -1; y <= 1; y++) {
            if (x === 0 && y === 0) continue;
            const newRow = (row + y + rows) % rows;
            const newCol = (col + x + cols) % cols;
            const cell = grid.getCell(newRow, newCol);
            const color = cell?.color;

            if (color) {
              neighbors[color] = (neighbors[color] || 0) + 1;
            }
          }
        }

        return neighbors;
      }

      /**
       * Move a cell in the grid from (sr, sc) to (dr, dc)
       */
      function tryMove(gridArr, sr, sc, dr, dc) {
        const nr = (sr + dr + rows) % rows;
        const nc = (sc + dc + cols) % cols;
        const dcell = gridArr[nr][nc];

        if (!dcell) {
          // Check if the destination cell is empty
          gridArr[nr][nc] = gridArr[sr][sc];
          gridArr[sr][sc] = null;

          return true;
        }

        return false;
      }

      function moveToTarget(gridArr, row, col, targetRow, targetCol) {
        const dRow = targetRow - row;
        const dCol = targetCol - col;
        let dr = 0,
          dc = 0;

        if (Math.abs(dRow) >= Math.abs(dCol)) dr = Math.sign(dRow);
        else dc = Math.sign(dCol);

        return tryMove(gridArr, row, col, dr, dc);
      }

      function moveAwayFromTarget(gridArr, row, col, targetRow, targetCol) {
        const dRow = targetRow - row;
        const dCol = targetCol - col;
        let dr = 0,
          dc = 0;

        if (Math.abs(dRow) >= Math.abs(dCol)) dr = -Math.sign(dRow);
        else dc = -Math.sign(dCol);

        return tryMove(gridArr, row, col, dr, dc);
      }

      function moveRandomly(gridArr, row, col, cell) {
        const { dr, dc } = cell.decideMove();

        return tryMove(gridArr, row, col, dr, dc);
      }

      function fightEnemy(manager, attackerRow, attackerCol, targetRow, targetCol) {
        const attacker = manager.grid[attackerRow][attackerCol];
        const defender = manager.grid[targetRow][targetCol];

        if (!defender) return;
        if (attacker.energy >= defender.energy) {
          manager.grid[targetRow][targetCol] = attacker;
          manager.grid[attackerRow][attackerCol] = null;
          manager.consumeEnergy(attacker, targetRow, targetCol);
        } else {
          manager.grid[attackerRow][attackerCol] = null;
        }
      }

      function cooperateWithEnemy(manager, row, col, targetRow, targetCol) {
        const cell = manager.grid[row][col];
        const partner = manager.grid[targetRow][targetCol];

        if (!partner) return;
        const share = Math.min(1, cell.energy / 2);

        cell.energy -= share;
        partner.energy = Math.min(GridManager.maxTileEnergy, partner.energy + share);
      }

      function applyEventEffects(cell, row, col, currentEvent) {
        if (
          currentEvent &&
          row >= currentEvent.affectedArea.y &&
          row < currentEvent.affectedArea.y + currentEvent.affectedArea.height &&
          col >= currentEvent.affectedArea.x &&
          col < currentEvent.affectedArea.x + currentEvent.affectedArea.width
        ) {
          const s = currentEvent.strength * EVENT_STRENGTH_MULTIPLIER;

          switch (currentEvent.eventType) {
            case 'flood': {
              const resist = cell.dna.floodResist();

              cell.energy -= 0.3 * s * (1 - resist);
              break;
            }
            case 'drought': {
              const resist = cell.dna.droughtResist();

              cell.energy -= 0.25 * s * (1 - resist);
              break;
            }
            case 'heatwave': {
              const resist = cell.dna.heatResist();

              cell.energy -= 0.35 * s * (1 - resist);
              break;
            }
            case 'coldwave': {
              const resist = cell.dna.coldResist();

              cell.energy -= 0.2 * s * (1 - resist);
              break;
            }
          }
          cell.energy = Math.max(0, Math.min(GridManager.maxTileEnergy, cell.energy));
        }
      }

      function update() {
        if (uiManager.isPaused()) {
          return;
        }

        const now = performance.now();
        const interval = 1000 / Math.max(1, updatesPerSecond);

        if (now - lastUpdateTime >= interval) {
          lastUpdateTime = now;
          grid.update();
        }
        grid.draw();
        requestAnimationFrame(update);
      }

      // Create grid using class
      const grid = new GridManager(rows, cols);
      const uiManager = new UIManager(update);

      requestAnimationFrame(update);
    </script>
  </body>
</html>
